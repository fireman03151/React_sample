---
title: Dining Philosophers Problem
localeTitle: 用餐哲学家的问题
---
## 用餐哲学家的问题

在计算机科学中，餐饮哲学家问题是在并发算法设计中经常使用的示例问题，以说明同步问题和解决它们的技术。它最初由Edsger Dijkstra于1965年制定，作为学生考试练习，以计算机竞争访问磁带机外围设备的形式呈现。不久之后，托尼·霍尔（Tony Hoare）提出了目前的问题。

简单来说，餐饮哲学家问题就是说明同步访问共享资源如何导致死锁情况的产生。

#### 同步和死锁

**同步**用于控制对共享资源的并发访问。在多个独立参与者可能竞争使用一种资源的任何情况下，这都是必要的。由于只有一个资源可用，我们使用同步来防止混乱和混乱。

**死锁**是一种无法进行的系统状态。当强制执行同步时，可能会发生这种情况，并且许多进程最终等待某个其他进程持有的共享资源。在这种情况下，进程只是等待并且不再执行。

#### 问题陈述

五位沉默的哲学家坐在圆桌旁，拿着一碗意大利面。叉子放置在每对相邻的哲学家之间。

每个哲学家都必须交替思考和吃饭。然而，一个哲学家只有吃左右叉时才能吃意大利面。每个分支只能由一位哲学家持有，因此只有当另一位哲学家没有使用它时，哲学家才能使用它。在一位个体哲学家吃完之后，他们需要放下两把叉子，以便叉子可供他人使用。一个哲学家可以在他们的右边或左边的那个上叉，因为它们变得可用，但是在获得两个叉子之前不能开始进食。 （ **同步** ）

进食不受意大利面条或胃部空间的限制;假设无限供应和无限需求。

问题是如何设计一个行为学科（并发算法），这样任何哲学家都不会饿死;也就是说，每个人都可以永远地继续在吃和思考之间交替，假设没有哲学家可以知道其他人何时可能想吃或想。 （ **死锁避免** ）

在前期，似乎不容易出现死锁。要看到对这个问题的正确解决方案并不明显，请考虑一个建议，其中每个哲学家的行为如下：

1.  想到左叉可用;什么时候，拿起来;
2.  想一想，直到右叉可用;什么时候，拿起来;
3.  当两个叉子都被抓住时，吃了一段固定的时间;
4.  然后，把右叉放下;
5.  然后，把左叉放下;
6.  从头开始重复。

此尝试的解决方案失败，因为它允许系统达到死锁状态，在该状态下无法进行。这是一个状态，每个哲学家都拿起了左边的叉子，正在等待右边的叉子变得可用，反之亦然。通过给定的指令，可以达到这种状态，当它到达时，哲学家将永远等待彼此释放分叉。 （ **僵局和饥饿** ）

有许多解决方案可以防止死锁。如果我们仔细观察，上面算法中的一个问题是所有哲学家都有相同的机会（具有相同的优先权）获得一个分叉。这可以防止任何人获得两把叉子，整个系统都会停止运转。

解决方案包括： -

1.  优先级 - 一些哲学家被赋予更高的优先级，因此获得两个叉子的机会增加。
2.  抢占（礼貌） - 哲学家放弃获得的叉子而不吃东西，以防其他叉子不可用。
3.  仲裁 - 调解员分配叉子，确保向一个人提供两把叉子，ibnstaed为一对多。

#### 更多信息：

https://www.wikiwand.com/en/Dining _哲学家的_问题