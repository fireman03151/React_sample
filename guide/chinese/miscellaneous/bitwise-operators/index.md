---
title: Bitwise Operators
localeTitle: 按位运算符
---
`<<` ， `>>` ， `&` ， `|` ， `~`和`^`是按位运算符，它们在各个位的级别上对一个或多个位模式或二进制数字进行操作。

## AND运算符

`x & y`

是“按位和”。如果y的x AND的相应位为1，则输出的每个位为1，否则为0。

## OR运算符

`x | y`

是“按位还是”。如果y的x AND的相应位为0，则输出的每个位为0，否则为1。

## 补充运算符

`~ x`

返回x的补码 - 通过将每个1切换为0并将每个0切换为1得到的数字。这与-x - 1相同。

## XOR运算符

`x ^ y`

是“按位排他性”还是“。如果y中的该位为0，则输出的每个位与x中的相应位相同，如果y中的该位为1，则它是x中位的补码。

## 算术移位左操作员

`x << y`

返回x，其中位向左移位y位（右侧的新位为零）。这与将x乘以2 \*\* y相同，保留数字的符号。当你使用count> = sizeof（type）进行移位时，大多数编译器都会发出警告。当你这样做时，你通常会得到一个0。

## 算术右移算子

`x >> y`

返回x，位向右偏移y位。这与将x除以2 \*\* y作为无符号整数相同。负签名号的右移具有实现定义的行为。当你使用count> = sizeof（type）进行移位时，大多数编译器都会发出警告。向右移位可以用原始最高有效位填充“空”位（即执行符号扩展），或者它可以以零移位，具体取决于平台和/或编译器。

## 逻辑右移算子

`x >>> y`

返回x，位向右偏移y位。与算术移位不同，逻辑移位不会预先设置符号。例如：以8位表示的-2将是11111110（因为最高有效位具有负权重）。使用算术移位将其向右移一位会给你11111111或-1。然而，逻辑右移并不关心价值可能代表一个数字;它只是将所有内容移动到右侧，并从左侧填充0。使用逻辑移位将我们的-2右移一位将给出01111111。此运算符不一定存在于所有语言中。