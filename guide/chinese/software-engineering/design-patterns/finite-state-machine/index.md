---
title: Finite State Machine
localeTitle: 有限状态机
---
有限状态机（FSM）是一种软件设计模式，其中给定模型通过外部输入转换到其他行为状态。

## 有限状态机

FSM由其**状态** ， **初始状态**和**转换定义** 。

FSM的力量来自于在不同条件下明确定义不同_行为_的能力。通常，FSM与循环行为脚本一起使用，该脚本不断地评估循环或事件中的当前情况。

为了帮助形成如何应用这一点的图像，将使用咖啡机作为有限状态机的示例。我们还将介绍状态图以可视化FSM并提供编码示例。

### 状态图

![咖啡机有限状态机图](https://raw.githubusercontent.com/arunma/blogimages/master/AkkaFSM/CoffeeMachineFSM.png) 该图显示了咖啡机的三种可能状态：

*   打开
*   ReadyToBuy
*   已关闭的

这些状态之间的线显示了状态之间和哪个方向可能的转换。这些转换具有FSM何时需要在状态之间切换的条件。

*   StartUpMachine 从PoweredOff状态到Open状态，机器必须启动。在这种情况下，这是手动完成的。
    
*   存款> =咖啡费用 FSM在一个循环或金额变化时评估存入的现金金额（在这种情况下推荐） 如果您将足够的现金存入咖啡机，FSM将从“打开”变为“ReadyToBuy”。
    
*   ShutdownMachine 如果满足“不再有咖啡”的条件，机器将通过ShutDownMachine方法自动从Open到PoweredOff。
    
*   DispenseCoffee 在ReadyToBuy状态下，用户可以购买咖啡，然后将其冲泡和分配。条件是BuyCoffee事件（！链接到观察者模式！）触发。 （未在图中显示）
    
*   CancelCoffee 如果用户选择取消，则机器将从ReadyToBuy转到Open。
    
*   ShutDownMachine 机器将进入PoweredOff状态
    

### 状态

在每个状态中都有定义的行为，只有在对象处于该状态时才会执行。例如，在PoweredOff期间，咖啡机在打开电源之前不会冲泡咖啡，在打开状态期间它将等待，直到插入足够的现金，直到给出断电命令，或者直到咖啡用完为止。在此打开状态期间，它可以执行诸如清洁之类的例程，这在其他状态下不会发生。

### 初始状态

每个FSM都有一个初始状态，这意味着它在创建时开始的状态，并且必须在构造或实例化时定义。当然，如果满足条件，可以直接改变状态。

### 转变

每个州要么经常评估它是否应该转换到另一个州，要么根据触发事件转换到另一个州。

## DFA和NFA

有限自动机有两种类型，确定性（DFA）和非确定性（NFA）。它们都接受常规语言并且以与上述相同的方式或多或少地操作，但是存在一些差异。

DFA接受或拒绝一串符号，并且仅为每个输入字符串生成一个唯一计算或自动机。 _确定性_是指计算的唯一性。 如果有限状态机遵循以下规则，则称为DFA：

1.  其每个转换由其源状态和输入符号_唯一_确定
2.  每次状态转换都需要读取输入符号。

NFA不需要遵守这些限制，这意味着每个DFA也是NFA。 由于它们都只识别常规语言，因此可以使用powerset构造算法将每个NFA转换为等效的DFA。

那么我们期望在NFA中找到哪种规则而不是DFA？

1.  NFA可以具有_空字符串_转换（通常用epsilon表示）。意味着当处于转换规则的epsilon的某个状态时，机器可以转换到下一个状态而不读取输入符号
2.  在NFA中，每对状态和转换符号可以具有多个目标状态，而不是DFA中的对的唯一目标
3.  每对状态和转换符号为其可能的每个目标生成计算的“分支”，从而创建某种多线程系统。
4.  如果输入字符串落在接受状态以外的任何状态，则DFA将拒绝输入字符串。在NFA中，我们只需要一个“分支”来接受接受状态以接受字符串。