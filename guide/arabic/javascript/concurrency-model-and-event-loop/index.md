---
title: Concurrency Model and Event Loop
localeTitle: نموذج التزامن وحلقة الحدث
---
## نموذج التزامن وحلقة الحدث

يكون وقت تشغيل جافا سكريبت واحدًا متسلسلًا مما يعني أنه يمكنه تنفيذ جزء واحد من الشفرة في كل مرة. لفهم نموذج التزامن وحلقة الحدث في جافا سكريبت ، يتعين علينا أولاً التعرف على بعض المصطلحات الشائعة المرتبطة بها. دعونا أولا نتعرف على ما هو مكدس المكالمات.

مكدس الاستدعاءات عبارة عن بنية بيانات بسيطة تسجل مكان التعليمة البرمجية التي نحن عليها حاليًا. لذا إذا قمنا بالانتقال إلى دالة تمثل استدعاء دالة ، فسيتم دفعها إلى مكدس الاستدعاءات وعندما نعود من إحدى الوظائف ، يتم إخراجها من المكدس.

لنأخذ مثال الكود لفهم مكدس المكالمات

```javascript
function multiply(x,y) {
   return x * y;
}

function squared(n) {
     return multiply(n,n)
  }

function printSquare(n) {
   return squared(n)
}

let numberSquared = printSquare(5);
console.log(numberSquared);
``` 

أولاً عند تنفيذ التعليمات البرمجية وقت التشغيل خلال كل تعريفات الدالة ولكن عندما يصل إلى السطر حيث يتم استدعاء الدالة الأولى **printSquare (5)** فإنه سيتم دفع هذه الوظيفة إلى مكدس الاستدعاءات. بعد ذلك ، ستنفذ هذه الوظيفة وستواجه ، قبل إعادتها ، دالة أخرى **مربعة (n)** بحيث ستعلق العملية الحالية وتدفع هذه الوظيفة إلى أعلى الوظيفة الحالية. ينفذ الدالة في هذه الحالة الدالة التربيعية وأخيرًا يواجه دالة أخرى **مضاعفة (n، n)** ومن ثم فإنه يعلق عمليات التنفيذ الحالية ويدفع هذه الوظيفة إلى مكدس الاستدعاءات. ينفذ ضرب ويعود مع قيمة مضروب. وأخيرًا ، ترجع الدالة التربيعية وتنبثق من الحزمة ثم ينتقل نفس الشيء مع printSquare. يتم تخصيص القيمة التربيعية النهائية للمتغير numberSquared. نحن نواجه مرة أخرى استدعاء دالة في هذه الحالة هو عبارة console.log () بحيث يدفع وقت التشغيل هذا إلى المكدس الذي ينفذها وبالتالي طباعة الرقم التربيعي على وحدة التحكم. وتجدر الإشارة إلى أن الوظيفة الأولى التي يتم دفعها إلى الكدسة قبل تشغيل أي من التعليمات البرمجية المذكورة أعلاه هي الوظيفة الرئيسية التي يُشار إليها في وقت التشغيل بأنها "وظيفة مجهولة".

لذلك لتلخيص كلما تم استدعاء دالة يتم دفعه إلى مكدس الاستدعاءات حيث ينفذ. وأخيرًا ، عندما يتم تنفيذ المهمة مع تنفيذها وتعود إما ضمنيًا أو صريحًا ، ستخرج من المكدس. مكدس الاستدعاءات يسجل فقط في أي وقت من الأوقات التي كانت تنفذ funciton. إنه يحتفظ بالوظيفة التي يتم تنفيذها حاليًا.

الآن نعرف من هذا أن جافا سكريبت تستطيع تنفيذ أمر واحد في كل مرة ولكن هذا ليس هو الحال مع المتصفح. يحتوي المتصفح على مجموعة خاصة به من API مثل setTimeout ، XMLHttpRequests والتي لم يتم تحديدها في وقت تشغيل Javascript. في الواقع ، إذا نظرت عبر شفرة المصدر لـ V8 ، فإن وقت تشغيل جافا سكريبت الشهير الذي يدعم المتصفحات مثل Google Chrome لن تجد أي تعريف له. يرجع السبب إلى وجود واجهة برمجة تطبيقات الويب الخاصة هذه في بيئة المتصفح وليس داخل بيئة جافا سكريبت ، ويمكنك القول أن هذه الواجهة تقدم التزامن في المزيج. دعونا ننظر إلى الرسم البياني لفهم الصورة بأكملها.

![التزامن ونموذج حدث حلقة](https://cdn-media-1.freecodecamp.org/imgr/rnQEY7o.png)

يتم تقديم بعض المصطلحات أكثر

**الكومة** - إنها في الغالب المكان الذي يتم فيه تخصيص الكائنات.

**Callback Queue** - هي بنية بيانات تخزن جميع عمليات الاسترجاعات. نظرًا لأنه طابورًا ، تتم معالجة العناصر استنادًا إلى FIFO والتي تكون الأولى في First Out.

**حدث حلقة** - هذا هو المكان الذي يجمع كل هذه الأشياء معا. ما تقوم به حلقة الحدث ببساطة هو أنها تتحقق من مكدّسات المكالمة وإذا كانت فارغة ، مما يعني عدم وجود وظائف في المكدس تستدعي أقدم رد اتصال من قائمة انتظار رد الاتصال ويدفعه إلى مكدس الاستدعاءات الذي ينفذ في النهاية رد الاتصال.

دعونا نفهم هذا مع مثال الكود

```javascript
console.log('hi');

setTimeout(function() {
     console.log('freecodeCamp')
},5000);

console.log('JS')
``` 

عندما ينفّذ السطر الأول ، يكون الأمر console.log () وهو عبارة عن استدعاء للوظيفة ، مما يعني أن هذه الوظيفة يتم دفعها إلى مكدس الاستدعاءات حيث تقوم بتنفيذ الطباعة "hi" إلى وحدة التحكم وأخيراً يتم إرجاعها ويتم إفراغها من المكدس. ثم عندما يذهب وقت التشغيل لتنفيذ setTimeout () فإنه يعرف أن هذا هو API على شبكة الإنترنت ، وبالتالي فإنه يعطيها إلى المتصفح للتعامل مع تنفيذ ذلك. يبدأ المتصفح في تشغيل جهاز ضبط الوقت ثم ينبثق وقت تشغيل JS في وضع setTimeout () خارج الحزمة. يواجه استدعاء آخر console.log () ومن ثم فإنه يدفع هذا في مكدس الاستدعاءات يتم تسجيل الرسالة 'JS' في وحدة التحكم ومن ثم يتم إرجاعها ومن ثم يتم إفراغ الأخير console.log () إيقاف المكدس. الآن مكدس الاستدعاءات فارغ. في الوقت نفسه بينما كان كل هذا يحدث على انتهاء جهاز ضبط الوقت الذي يكون عند مرور 5 ثوان ، ينتقل المتصفح ويدفع وظيفة رد الاتصال إلى قائمة انتظار رد الاتصال. بعد ذلك ، تقوم حلقة الحدث بالتحقق مما إذا كانت مكدس الاستدعاءات مجاني أم لا. نظرًا لأنه مجاني ، فإنه يأخذ وظيفة رد الاتصال ويدفعه مرة أخرى إلى مكدس الاستدعاءات الذي ينفذ الشفرة بداخله. مرة أخرى داخل التعليمات البرمجية هناك استدعاء console.log () بحيث تنتقل هذه الوظيفة إلى الجزء العلوي من المكدس الذي يسجل "freecodecamp" في وحدة التحكم وأخيراً يتم إرجاعه يعني أنه يحصل poppped إيقاف المكدس وأخيراً ينفجر رد الاتصال من المكدس وإننا انتهينا.

لتصور هذا أفضل محاولة هذه الأداة من قبل فيليب روبرتس- [لووب الحدث حلقة متخيل](http://latentflip.com/loupe/?code=!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D)

#### معلومات اكثر:

[فيليب روبرتس: ما هيك هو حلقة الحدث على أي حال؟ | JSConf EU 2014](https://www.youtube.com/watch?v=8aGhZQkoFbQ)

[نموذج التزامن وحلقة الحدث MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)