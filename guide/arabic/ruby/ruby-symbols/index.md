---
title: Ruby Symbols
localeTitle: روبي الرموز
---
## روبي الرموز

يشبه الرمز اسم المتغير ولكنه مسبوقًا بنقطتين. أمثلة -: الإجراء ،: line\_items. ليس عليك أن تعلن عن رمز مسبق وأن تكون مضمونة لتكون فريدة من نوعها. ليس هناك حاجة لتعيين نوع من القيمة لرمز - يعتني روبي بذلك بالنسبة لك. يضمن Ruby أيضًا أنه بغض النظر عن مكان ظهوره في برنامجك ، سيكون له رمز معين نفس القيمة.

بدلاً من ذلك ، يمكنك اعتبار القولون يعني "الشيء المسمى" ، لذلك: id هو "الاسم المسمى id". يمكنك أيضًا التفكير في: id على أنه يعني اسم معرف المتغير ، والمعرف العادي على أنه يعني قيمة المتغير.

على سبيل المثال: إذا كان Fred ثابتًا في سياق واحد ، وطريقة في أخرى ، وفئة في الثلث ، فسيكون الرمز: Fred هو نفس الكائن في جميع السياقات الثلاثة.

 `module One 
  class Fred 
  end 
  $f1 = :Fred 
 end 
 module Two 
  Fred = 1 
  $f2 = :Fred 
 end 
 def Fred() 
 end 
 $f3 = :Fred 
 $f1.object_id   #=> 2514190 
 $f2.object_id   #=> 2514190 
 $f3.object_id   #=> 2514190 
` 

## العمل مع الرموز

يمكنك التعرف على رمز Ruby لأنه سيكون كلمة تبدأ بـ:.

حتى الآن رأيناهم كمفتاح في هاش (العمل مع الزنانير في روبي):

 `person = {:name => "Philip"} 
` 

لذا ، فإن أول شيء يمكننا القيام به هو فحص الرمز لمعرفة الفئة التي يستخدمها:

 `:hello.class 
 => Symbol 
 
 "hello".class 
 => String 
` 

حتى يمكننا أن نرى أن الرموز والسلاسل هي أمثلة لكائنين مختلفين.

يمكنك الاتصال بأساليب شبيهة `upcase` ، مثل `upcase` ، و `downcase` ، `capitalize` الرموز:

 `:hello.upcase 
 => :HELLO 
 
 :HELLO.downcase 
 => :hello 
 
 :hello.capitalize 
 => :Hello 
` 

## لماذا تستخدم رمزًا بدلاً من سلسلة؟

إذا كان الرمز مجرد سلسلة غير قابلة للتغيير ، فلماذا تستخدمها ، ولماذا يوجد تمييز خاص في روبي؟

## الرموز هي غير قابل للتغيير

أولاً ، أحد الأسباب الرئيسية هو ، كما ذكرت أعلاه ، أن الرموز غير قابلة للتغيير. يمكن أن تظهر أخطاء غير متوقعة في التطبيق الخاص بك عندما يمكن تغيير قيمة. إذا كنت بحاجة إلى التأكد من عدم تغيير قيمة الكائن أبدًا ، يكون استخدام كائن غير قابل للتغيير أكثر أمانًا.

ومع ذلك ، مع ذلك ، يمكن إجراء سلسلة غير قابلة للتغيير في Ruby عن طريق استدعاء طريقة `freeze` :

 `name = "Philip" 
 => "Philip" 
 
 name.freeze 
 => "Philip" 
 
 name << "Jim" 
 RuntimeError: can't modify frozen String 
` 

كما ترى في المثال أعلاه ، بمجرد استدعاء طريقة التجميد على مثيل سلسلة ، لن يمكنك تعديله بعد الآن.

فلماذا يمكنك استخدام الرموز بدلاً من السلاسل؟

#### الرموز أفضل للأداء

السبب الثاني وراء استخدامك لـ Symbol على إحدى سلاسل String في مواقف معينة هو أن الرموز أفضل بكثير من حيث الأداء.

فمثلا:

 `philip".object_id 
 => 70288511587360 
 "philip".object_id 
 => 70288504327720 
 
 :philip.object_id 
 => 539368 
 :philip.object_id 
 => 539368 
` 

عند إنشاء كائنين سلسلة بنفس القيمة ، يتم التعامل مع هذين العنصرين ككائنين مختلفين. عند إنشاء رمز ، سيستخدم الرجوع إلى الرمز دائمًا نفس الكائن.

هذا أفضل بكثير للأداء نظرًا لأنه سيتم إنشاء نفس كائن السلسلة وتدميره مرارًا وتكرارًا ، في حين أنه في الواقع يمكن إعادة استخدام الكائن نفسه في كل مرة.

#### طرق الطبقة العامة

all\_symbols => نقر المصفوفة لتبديل المصدر لإرجاع مجموعة من الرموز الموجودة حاليًا في جدول رمز Ruby.

 `Symbol.all_symbols.size    #=> 903 
 Symbol.all_symbols[1,20]   #=> [:floor, :ARGV, :Binding, :symlink, 
                                :chown, :EOFError, :$;, :String, 
                                :LOCK_SH, :"setuid?", :$<, 
                                :default_proc, :compact, :extend, 
                                :Tms, :getwd, :$=, :ThreadGroup, 
                                :wait2, :$>] 
` 

#### معلومات اكثر:

[روبي الرموز الوثائق](http://ruby-doc.org/core-2.5.1/Symbol.html)