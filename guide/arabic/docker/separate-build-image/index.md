---
title: Separate Build Image
localeTitle: صورة بناء منفصلة
---
## نظرة عامة

جعل صور عامل ميناء خفيفة الوزن هو مفتاح وجود خط أنابيب سريع التطوير / النشر. بالنسبة إلى الشفرات المترجمة ، فإن بناء الملف الثنائي داخل حاوية عامل ميناء له فائدة من كونه عملية إنشاء متكررة وموحدة. ومع ذلك ، يمكن لهذا إنشاء صور كبيرة جدًا يمكن أن تصبح مشكلة أسفل الخط.

## لدينا الكود

في هذا المثال ، سنستخدم خادمًا بسيطًا لخادم الويب في [Go](https://golang.org/) . التعليمة البرمجية التالية هي مجرد webserver hello world يستمع على المنفذ `8080` .

```go
package main

import (
    "fmt"
    "log"
    "net/http"
)

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "Hello world!")
}

func main() {
    http.HandleFunc("/", handler)
    log.Fatal(http.ListenAndServe(":8080", nil))
}
``` 

### Dockerfile

قد يبدو Dockerfile لهذا الرمز شيء من هذا القبيل

```
FROM golang:1.11

ADD . /app

WORKDIR /app

RUN go build -o /myserver .

EXPOSE 8080

CMD [ "/myserver" ]
``` 

بناء هذه الصورة ينتج في صورة بحجم 783MB !! باستخدام صورة بهذا الحجم للتطبيق البسيط ، من السهل رؤية كيف يمكن أن يؤدي ذلك إلى إبطاء الأشياء عند النشر.

## حل أفضل

الحل الأفضل هو استخدام صورة بناء منفصلة لبناء الملف الثنائي ثم نسخه إلى الصورة النهائية. كما يولد Go بثًا مستقلاً ، يمكننا استخدام صورة docker `scratch` كقاعدة صغيرة جدًا بقدر ما تحصل عليه!

### Dockerfile

سيقوم Dockerfile التالي ببناء الثنائي داخل صورة golang ومن ثم بناء صورة جديدة من الصفر ، نسخ الملف الثنائي من الصورة الأولى إلى الثانية.

```
FROM golang:1.11 as build

ADD . /app

WORKDIR /app

RUN go build -o /myserver .


FROM scratch

COPY --from=build /myserver /myserver

EXPOSE 8080

CMD [ "myserver" ]
``` 

بناء من هذا dockerfile النتائج في حجم الصورة النهائية من 6.55MB فقط! هذا **أصغر** من **100 مرة** من محاولتنا الأولى ، مما يجعله أسرع 100 مرة في سحب الصورة من التسجيل!

### مكافأة منحة

ليس لدينا الآن فقط صورة رصيف صغيرة لتطبيقنا ، بل يجب علينا فقط أن نقلق بشأن أمن تطبيقنا لأنه لا يوجد برنامج آخر يعمل داخل الحاوية.