---
title: Algorithm Performance
localeTitle: أداء الخوارزمية
---
في الرياضيات ، يعتبر التدرج الكبير O رمزية تستخدم لوصف ومقارنة _السلوك المحدد_ لوظيفة ما.  
السلوك المحدود للوظيفة هو كيفية تصرف الدالة لأنها تميل إلى قيمة معينة وفي التدوين الكبير ، عادةً ما تكون في اتجاه الاتجاهات نحو اللانهاية.  
باختصار ، يستخدم الترميز الكبير O لوصف نمو أو انخفاض وظيفة ، عادةً فيما يتعلق بوظيفة أخرى.

في تصميم الخوارزمية ، نستخدم عادةً تدوينًا كبيرًا لأننا نستطيع أن نرى كيف تعمل الخوارزمية السيئة أو الجيدة في أسوأ وضع. ولكن ضع في اعتبارك أنه ليس دائمًا الحالة نظرًا لأن الحالة الأسوأ قد تكون نادرة جدًا وفي هذه الحالات نحسب متوسط ​​الحالة. في الوقت الراهن لئلا تفريغ كبير O- التأويل.

في الرياضيات ، يعتبر التدرج الكبير O رمزية تستخدم لوصف ومقارنة _السلوك المحدد_ لوظيفة ما.

السلوك المحدود للوظيفة هو كيفية تصرف الدالة لأنها تتجه نحو قيمة معينة وفي التدوين الكبير ، عادة ما تكون في الاتجاه نحو اللانهاية.

باختصار ، يستخدم الترميز الكبير O لوصف نمو أو انخفاض وظيفة ، عادةً فيما يتعلق بوظيفة أخرى.

ملاحظة: x ^ 2 يساوي x \* x أو 'x-squared'\]

على سبيل المثال ، نقول إن x = O (x ^ 2) لكل x> 1 أو بمعنى آخر ، x ^ 2 هو الحد الأعلى على x وبالتالي فإنه ينمو بشكل أسرع.  
يمكن استبدال رمز المطالبة مثل x = O (x ^ 2) لجميع x> _n_ بـ x <= x ^ 2 لجميع x> _n_ حيث _n_ هو أدنى رقم يفي بالمطالبة ، في هذه الحالة 1.

على نحو فعال ، نقول أن الدالة f (x) التي تمثل O (g (x)) تنمو أبطأ من g (x).

بشكل مقارن ، في علم الحاسوب وتطوير البرمجيات ، يمكننا استخدام التدوين الكبير O من أجل وصف كفاءة الخوارزميات عبر تعقيدها الزمني والفضائي.

يشير **تعقيد الفضاء** لخوارزمية إلى أثر ذاكرتها فيما يتعلق بحجم الإدخال.

على وجه التحديد عند استخدام تدوين كبير O ، فإننا نوضح كفاءة الخوارزمية فيما يتعلق بمدخلات: _n_ ، عادة عندما يقترب _n من_ اللانهاية.  
عند فحص الخوارزميات ، نرغب عمومًا في تقليل وقت وتعقيد المساحة. تعقيد زمن o (1) يدل على الوقت الثابت.

من خلال مقارنة وتحليل الخوارزميات نحن قادرون على إنشاء تطبيقات أكثر كفاءة.

لأداء الخوارزمية لدينا عاملين رئيسيين:

*   **الوقت** : نحتاج إلى معرفة مقدار الوقت المستغرق لتشغيل خوارزمية لبياناتنا وكيفية نموها حسب حجم البيانات (أو في بعض الحالات عوامل أخرى مثل عدد الأرقام وغيرها).
    
*   **الفضاء** : ذاكرتنا مهيبة لذلك علينا أن نعرف مقدار المساحة الخالية التي نحتاجها لهذه الخوارزمية ، ومثل الوقت نحتاج إلى أن نكون قادرين على تتبع نموها.
    

تستخدم الترميزات الثلاث التالية في معظمها لتمثيل تعقيد خوارزميات الوقت:

1.  **Θ التدوين** : تدوين ثيتا يقيّد الدوال من فوق وأسفل ، لذلك يعرّف السلوك الدقيق. يمكننا القول أن لدينا تدوين ثيتا عندما تكون الحالة الأسوأ وأفضل حالة هي نفسها.
    
    > Θ (g (n)) = {f (n): توجد ثوابت موجبة c1 و c2 و n0 بحيث 0 = = c1 _g (n) <= f (n) <= c2_ g (n) لجميع n> = n0}
    
2.  **Big O Notation** : يعرّف تدوين Big O الحد الأعلى لخوارزمية. على سبيل المثال ، يأخذ "فرز الإدراج" وقتًا خطيًا في أفضل الحالات والوقت التربيعي في أسوأ الحالات. يمكننا القول بأمان أن تعقيد وقت إدراج الإدراج هو _O_ ( _n ^ 2_ ).
    
    > O (g (n)) = {f (n): توجد ثوابت موجبة c و n0 مثل 0 <= f (n) <= cg (n) لجميع n> = n0}
    
3.  **Ω التدوين** : Ω الترميز يوفر الحد الأدنى من الخوارزمية. يظهر أسرع إجابة ممكنة لتلك الخوارزمية. > Ω (g (n)) = {f (n): توجد ثوابت موجبة c و n0 مثل 0 <= cg (n) <= f (n) لجميع n> = n0}.
    

## أمثلة

وكمثال على ذلك ، يمكننا فحص مدى تعقيد خوارزمية [\[الفقاعة التفسيرية\]](https://github.com/FreeCodeCamp/wiki/blob/master/Algorithms-Bubble-Sort.md#algorithm-bubble-sort) وتعبر عن ذلك باستخدام التدوين الكبير O.

#### فقاعة الفرز:

 `    // Function to implement bubble sort 
    void bubble_sort(int array<a href='http://bigocheatsheet.com/' target='_blank' rel='nofollow'>], int n) 
    { 
        // Here n is the number of elements in array 
        int temp; 
        for(int i = 0; i < n-1; i++) 
        { 
            // Last i elements are already in place 
            for(int j = 0; j < ni-1; j++) 
            { 
                if (array[j] > array[j+1]) 
                { 
                    // swap elements at index j and j+1 
                    temp = array[j]; 
                    array[j] = array[j+1]; 
                    array[j+1] = temp; 
                } 
            } 
        } 
    } 
` 

النظر في هذا القانون، يمكننا أن نرى أنه في أفضل السيناريوهات حيث يتم فرز مجموعة بالفعل، فإن البرنامج يجعل فقط _ن_ والمقارنات كما لا مقايضة يحدث.  
لذلك يمكننا القول أن أفضل تعقيد لحالة وقت نوع الفقاعة هو O ( _n_ ).

عند فحص سيناريو الحالة الأسوأ حيث تكون المصفوفة بترتيب عكسي ، سيؤدي التكرار الأول إلى إجراء مقارنات _n_ بينما سيتعين على التالي إجراء مقارنات _n_ - 1 وما إلى ذلك حتى يتم إجراء مقارنة واحدة فقط.  
ومن ثم ، فإن التدوين الكبير O لهذه الحالة هو _n_ \* \[( _n_ - 1) / 2\] والتي = 0.5 _n_ ^ 2 - 0.5 _n_ = O ( _n_ ^ 2) حيث أن _n n_ ^ 2 يهيمن على الوظيفة التي تسمح لنا تجاهل المصطلح الآخر في الوظيفة.

يمكننا التأكد من هذا التحليل باستخدام \[هذه الورقة الغنائية سهلة الاستخدام الكبيرة التي تتميز بتعقيد وقت O كبير للعديد من هياكل البيانات والخوارزميات الشائعة الاستخدام

من الواضح جداً أنه في حالات الاستخدام الصغيرة ، قد يكون هذا التعقيد الزمني على ما يرام ، وعلى نحو كبير ، لا يكون فرز الفقاعات على نطاق واسع حلاً جيدًا للفرز.  
هذه هي قوة التدوين الكبير: فهي تسمح للمطورين برؤية الاختناقات المحتملة لتطبيقهم بسهولة ، واتخاذ خطوات لجعلها أكثر قابلية للتوسع.

لمزيد من المعلومات حول سبب أهمية تحليلات big-O و algorithm ، قم بزيارة [تحدي الفيديو](https://www.freecodecamp.com/videos/big-o-notation-what-it-is-and-why-you-should-care) هذا!