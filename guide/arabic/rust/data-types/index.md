---
title: Rust Data Types
localeTitle: أنواع البيانات الصدأ
---
يعد فهم نظام كتابة لغة البرمجة أمرًا ضروريًا لبدء استخدام برامج الكتابة. نظام الكتابة هو ببساطة نظام يفرض عليك لغة برمجة لتخزين المعلومات في البيانات. إذا كنت مطورًا قادمًا من C / C ++ ، فقد تكون بعض أنواع البيانات هذه مألوفة لك بالفعل.

دعونا ننظر في أنواع بدائية من الصدأ

* * *

عندما ننظر إلى الصدأ ، نرى لغة تضع المزيد من التركيز على **سلامة الأنواع** . وهذا يعني أن التفاعل والتعامل مع كيفية قيام المبرمج بتخزين البيانات ، يكون المترجم أكثر صرامة ولا يرحم. أحد الأمثلة (التي سنرى قريبا) يتم تقديمها من خلال **التحذيرات** .

الصدأ هو أيضا لغة برمجة مكتوبة بشكل ثابت. هذا يعني أنه عندما يتم ترجمة البرنامج (المعروف أيضًا باسم وقت _التحويل البرمجي_ ) ، يجب معرفة نوع المتغيرات الخاصة بك. الصدأ لديه خيار توفير أنواع _ضمنية_ أو _صريحة_ .

### الأعداد الصحيحة

دعونا نرى كيف تعمل أنواع _ضمنية_ أو _صريحة من_ خلال إعلان عدد صحيح بسيط.

 `let number = 13; 
` 

أعلنا عن متغيرنا ، `number` ليعادل قيمة 13. عندما نقوم بتجميع ذلك ، يعرف Rust أن نوع الرقم هو `i32` ، المعروف أيضًا باسم عدد صحيح 32 بت. إذا أردنا القيام بذلك _بشكل صريح_ ، يمكننا أن نعلن عن المتغير على النحو التالي:

 `let number: i32 = 13; 
` 

بالطبع ، `i32` ليس النوع الوحيد الذي يمكننا تحديده. هنا جدول من أنواع `integer` الأخرى التي يمكنك تنفيذها. ضع في اعتبارك أن هذه _ذات حجم ثابت_ ، وعدد البتات المقابل للنوع هو عدد البتات التي يمكن تخزينها في هذا المتغير.

| الحجم | وقعت | غير الموقعة | | ----- | ---- | --- | | 8 بت | i8 | u8 | | 16 بت | i16 | u16 | | 32 بت | i32 | u32 | | 64 بت | i64 | u64 |

تمثل ( `i` prepend) والتوقيع غير الموقعة ( `u` prepend) ما إذا كانت المتغيرات التي نعلن عنها إيجابية أم سلبية ، على التوالي.

لديه الصدأ أيضا `isize` و `usize` نوع، والتي سوف تعتمد على هندسة الكمبيوتر الخاص بك. إذا كنت تستخدم بنية 64 بت ، فسيكون لديك متغير 64 بت. إذا كنت تعمل على بنية 32 بت ، فسوف يكون لديك متغير 32 بت.

### العربات

يحتوي الصدأ أيضًا على دعم للقيم العائمة أو القيم العشرية.

 `let floaty = 3.0; // type is f64 
` 

المتغير `floaty` أعلن ضمنيا أن يكون `f64` نوع، أو تعويم 64 بت. إذا كنت تريد `f32` ، يمكنك إجبار متغير إما أن يكون صريحًا ، أو إلحاق الكتابة بنهاية قيمة المتغير:

 `let float1: f32 = 4.5; // type is f32 
 let float2 = 5f32;   // type is f32 
` 

يمكنك أن ترى أن `float2` هو الآن `f32` ، على الرغم من أنه يحتوي على قيمة غير عشرية. بواسطة إلحاق `f32` ، `float2` لتمثيل نوع `f32` .

## القيم المنطقية

في كل لغة برمجة ، تكون قيم booleans ( `true` و `false` ) موجودة دائمًا بشكل ما. الصدأ لديه دعم لهذا من خلال نوع `bool` .

 `let t = true; 
 let f: bool = false; 
` 

## العمليات العددية

مع ذلك ، يمكننا الآن استخدام Rust لإجراء عمليات عددية بسيطة. لاحظ كيف يتم تقييد أنواع الحسابات بالأنواع الخاصة بها فقط.

 `let a = 4 + 5;        // => 9 
 let b = 5.0 - 4.0;    // => 1.0 
 let c = 3 * 4.0;      // => ERROR! 
 let d = 6.0 / 2.0;    // => 3.0 
 let e = 10 % 4;       // => 2 
` 

## تحذيرات!

دعونا ننظر إلى بعض المشاكل المحتملة التي يمكن أن تكون موجودة بالفعل في الصدأ. منذ استخدام البيانات بكفاءة والتأكد من أن المتغيرات التي نقوم بإنشائها يتم استخدامها بالفعل ، ستقوم Rust بطرح التحذيرات للمتغيرات غير المستخدمة:

 `fn main(){ 
  let a = 4; 
  // and now we close our program. 
 } 
` 

الآن إذا قمنا بتشغيل هذا البرنامج:

 ``warning: unused variable: `a` 
`` 

من المهم أن تتذكر دائمًا استخدام المتغيرات الخاصة بنا ، وإذا لم يكن الأمر كذلك ، فقم بتعليقها أو إزالتها!

## قراءة المزيد:

https://doc.rust-lang.org/book/second-edition/ch03-02-data-types.html