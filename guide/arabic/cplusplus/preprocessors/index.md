---
title: Preprocessors
localeTitle: Preprocessors
---
## Preprocessors in C / CPP

كما يشير الاسم ، فإن Preprocessors هي البرامج التي تعالج شفرة المصدر الخاصة بنا قبل تجميعها. هناك عدد من الخطوات المتبعة بين كتابة البرنامج وتنفيذ برنامج في C / C ++. دعونا نلقي نظرة على هذه الخطوات قبل أن نبدأ في التعلم عن Preprocessors.

![IMG](https://cdn-media-1.freecodecamp.org/imgr/Pb0aTkV.png)

يمكنك رؤية الخطوات الوسيطة في الرسم البياني أعلاه. يتم تخزين التعليمات البرمجية المصدر المكتوبة من قبل المبرمجين في الملف program.c. ثم يتم معالجة هذا الملف بواسطة preprocessors ويتم إنشاء ملف تعليمات برمجية مصدر موسع يسمى البرنامج. يتم تجميع هذا الملف الموسّع بواسطة المحول البرمجي ويتم إنشاء ملف رمز الكائن المسمى program.obj. وأخيرًا ، يربط رابط ملف كود الكائن هذا برمز الكائن لوظائف المكتبة لإنشاء ملف البرنامج التنفيذي القابل للتنفيذ.

توفر برامج Preprocessor تعليمات preprocessors التي تخبر المترجم ببرمج المصدر قبل التحويل البرمجي. كل من هذه التوجيهات preprocessor يبدأ برمز `#` (التجزئة). يشير هذا الرمز ('#') في بداية العبارة في برنامج C / C ++ إلى أنه توجيه ما قبل المعالج. يمكننا وضع توجيهات المعالج السابقة في أي مكان في برنامجنا. أمثلة لبعض التوجيهات preprocessor هي: `#include` ، `#define` ، `#ifndef` etc.

### أنواع التوجيهات preprocessor:

1.  وحدات الماكرو
2.  تضمين ملف
3.  تجميع شرطي
4.  التوجيهات الأخرى

### وحدات الماكرو:

وحدات الماكرو هي جزء من التعليمات البرمجية في برنامج الذي يتم إعطاء بعض الاسم. كلما تمت مصادفة هذا الاسم بواسطة المحول البرمجي ، يستبدل المحول البرمجي الاسم بقطعة الشفرة الفعلية. يتم استخدام `#define` التوجيه لتعريف ماكرو.

 `  #include<iostream> 
  #define LIMIT 3 
  int main() 
  { 
    for(int i=0; i < LIMIT; i++) 
    { 
      std::cout<<i<<" " ; 
    } 
      return 0; 
  } 
` 

انتاج:

`0 1 2`

في البرنامج أعلاه ، عندما ينفذ المحول البرمجي الكلمة `LIMIT` فإنه يستبدلها بـ 3. الكلمة `LIMIT` في تعريف الماكرو تسمى قالب الماكرو و "3" هي امتداد الماكرو.

يجب ألا يكون هناك منقوطة ('؛') في نهاية تعريف الماكرو. لا تحتاج تعريفات ماكرو إلى فصل منقوطة.

### تضمين ملف:

يخبر هذا النوع من التوجيهات preprocessor المحول البرمجي لتضمين ملف في برنامج التعليمات البرمجية المصدر. هناك نوعان من الملفات التي يمكن تضمينها من قبل المستخدم في البرنامج:

*   \#### Header File أو الملفات القياسية: تحتوي هذه الملفات على تعريف للوظائف المحددة مسبقًا مثل printf () ، ... scanf () وما إلى ذلك. يجب تضمين هذه الملفات للعمل مع هذه الوظائف. ... يتم الإعلان عن وظيفة مختلفة في ملفات رؤوس مختلفة. على سبيل المثال ... تميز عمليات I / O القياسية في ملف 'iostream' بينما تكون الدوال التي ... تنفذ عمليات السلسلة في ملف 'string'.

#### بناء الجملة:

`#include< file_name >` حيث file\_name هو اسم الملف المراد تضمينه. يخبر الأقواس `<` و `>` المحول البرمجي للبحث عن الملف في الدليل القياسي.

*   \#### ملفات تعريف المستخدم: عندما يصبح البرنامج كبيرًا جدًا ، من الأفضل تقسيمه إلى ملفات أصغر وتضمينه عند الحاجة. هذه الأنواع من الملفات هي ملفات محددة من قبل المستخدم. يمكن تضمين هذه الملفات على النحو التالي: ... `#include"filename"`

### التجميع الشرطي:

توجيهات الترجمة الشرطية هي نوع من التوجيهات التي تساعد على تجميع جزء معين من البرنامج أو تخطي تجميع جزء معين من البرنامج على أساس بعض الشروط. يمكن القيام بذلك بمساعدة اثنين من الأوامر preprocessing `ifdef` و `endif` .

#### بناء الجملة:

 `  ifdef macro_name 
    statement1; 
    statement2; 
    statement3; 
    . 
    . 
    . 
    statementN; 
  endif 
` 

إذا تم تعريف الماكرو بالاسم "macroname" ، فسيتم تنفيذ كتلة البيانات بشكل طبيعي ولكن إذا لم يتم تعريفها ، فسيخسر المجمع ببساطة هذه المجموعة من العبارات.

### التوجيهات الأخرى:

بصرف النظر عن التوجيهات المذكورة أعلاه ، هناك توجيهان آخران لا يستخدمان بشكل شائع. هؤلاء هم:

1.  \##### `#undef` Directive: يتم استخدام الأمر `#undef` ماكرو موجود. يعمل هذا التوجيه على النحو التالي:

##### بناء الجملة:

`#undef LIMIT` سيؤدي استخدام هذا البيان إلى إلغاء تحديد LIMIT الماكرو الحالي. بعد هذا البيان سيتم تقييم كل عبارة `#ifdef LIMIT` إلى false.

2.  \##### `#pragma` Directive: هذا التوجيه هو توجيه خاص الغرض ويستخدم لتشغيل أو إيقاف بعض الميزات. هذا النوع من التوجيهات خاص بالمتحول ، أي أنها تختلف من مترجم إلى مترجم. بعض من `#pragma` توجيهات نوقشت أدناه:

##### `#pragma startup` و `#pragma exit` :

تساعدنا هذه التوجيهات على تحديد الوظائف المطلوبة للتشغيل قبل بدء تشغيل البرنامج (قبل أن يمرر التحكم إلى main ()) وقبل مخرج البرنامج (فقط قبل إرجاع عنصر التحكم من main ()).

 `#include<stdio.h> 
 void func1(); 
 void func2(); 
 #pragma startup func1 
 #pragma exit func2 
 void func1() 
 { 
    printf("Inside func1() "); 
 } 
 void func2() 
 { 
    printf("Inside func2() "); 
 } 
 int main() 
 { 
    printf("Inside main() "); 
 
    return 0; 
 } 
` 

انتاج:  
`Inside func1() Inside main() Inside func2()`  
سينتج الكود الموضح أعلاه الناتج كما هو موضح أدناه عند تشغيله على compilers GCC:  
انتاج:  
`Inside main()`  
يحدث هذا لأن GCC لا يدعم #pragma بدء التشغيل أو الإنهاء. ومع ذلك ، يمكنك استخدام الشفرة التالية للحصول على إخراج مشابه من المترجمين في دول مجلس التعاون الخليجي.

 `#include<stdio.h> 
 void func1(); 
 void func2(); 
 void __attribute__((constructor)) func1(); 
 void __attribute__((destructor)) func2(); 
 void func1() 
 { 
    printf("Inside func1()\n"); 
 } 
 void func2() 
 { 
    printf("Inside func2()\n"); 
 } 
 int main() 
 { 
    printf("Inside main()\n"); 
 
    return 0; 
 } 
` 

##### `#pragma warn` التوجيه:

يتم استخدام هذا التوجيه لإخفاء رسالة التحذير التي يتم عرضها أثناء التحويل البرمجي. يمكننا إخفاء التحذيرات كما هو موضح أدناه:

##### `#pragma warn -rvl` :

يخفي هذا التوجيه تلك التحذيرات التي تثار عندما لا تقوم دالة من المفترض أن تقوم بإرجاع قيمة بإرجاع قيمة.

##### `#pragma warn -par` :

يخفي هذا التوجيه تلك التحذيرات التي تثار عندما لا تستخدم وظيفة المعلمات التي تم تمريرها إليه.

##### `#pragma warn -rch` :

يخفي هذا التوجيه تلك التحذيرات التي يتم رفعها عندما يكون الرمز غير قابل للوصول. على سبيل المثال: أي رمز مكتوب بعد عبارة الإرجاع في إحدى الوظائف غير قابل للوصول.