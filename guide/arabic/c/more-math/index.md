---
title: More math
localeTitle: المزيد من الرياضيات
---
# المزيد من الرياضيات في C

حسنًا ، لقد رأيت الأساسيات. هناك الكثير هناك في C ، على الرغم من ذلك ، وهنا نظرة على ذلك.

## ترتيب العمليات

ألق نظرة على المعادلة التالية:

> 1 + (3-2) \* 5

إذا أردنا أن نقرأ ونحسب ببساطة من اليسار إلى اليمين ، فإننا سنأخذ 1 ، نضيف 3 ، نطرح 2 ، ونتضاعف في 5 ، و نحصل على 10. لكن هذا يهمل ترتيب العمليات. يجب أن نفعل (3-2) أولاً ، الحصول على 1 ، ثم ضرب 5 ، ثم أضف 1. هذا يعطي إجابة 6.

وكما هو الحال في الرياضيات العادية ، فإن C لديها ترتيب عمليات. العمليات لها الأسبقية ، وإذا كانت إحدى العمليات لها أسبقية من الأخرى ، فسيتم حساب الأسبقية الأولى أولاً. يمكن أن يؤدي استخدام الأقواس إلى زيادة هذه الأسبقية ، تمامًا كما هو الحال في الرياضيات العادية.

## العمليات الأحادية

العمليات غير الموحدة هي العمليات التي لا يوجد بها سوى متغير واحد. هناك عدد قليل في C.

### عوامل ما بعد الإصلاح والعمليات المسبقة

هناك الكثير من المواقف التي تريد فيها أخذ رقم وإما إلى الأعلى أو الأسفل بنسبة 1. بالنسبة لهذه الحالات ، لدينا عوامل تشغيل ما بعد الإصلاح والإصلاحات المسبقة:

```C
1: a++;
2: ++a;

3: a--;
4: --a;
``` 

كلا المثالين 1 و 2 سيزيدان قيمة الواحد تلو الآخر. كل من الأمثلة في 3 و 4 سيقلل من قيمة واحدة. ومع ذلك ، 1 لا تفعل نفس الشيء تمامًا مثل 2 ، و 3 لا تفعل نفس الشيء تمامًا مثل 4. تسمى عوامل ما قبل الإصلاح هذا لأن العملية هي البادئة (2 و 4 هي مشغلات البادئة لدينا). ﯾﻌﻣل ھذا ﺑﺷﮐل طﻔﯾف ﺑﺷﮐل ﻣﺧﺗﻟف ﻋن ﻣﺷﻐﻟﻲ ﻣﺎ ﺑﻌد اﻹﺻﻼح ﻓﻲ 1 و 3. ﯾﻘوم اﻟﻣﺷﻐﻟون ﻣﺳﺑﻘًﺎ ﺑﺈﺟراء اﻟﻌﻣﻟﯾﺔ ، ﺛم إﻋﺎدة اﻟﻘﯾﻣﺔ. عاملو الإصلاح اللاحق يعيدون القيمة ، ثم يقومون بالتزايد.

### Unary plus و ناقص

في الرياضيات العادية التي اعتدت عليها ، يمكنك استخدام "-" أمام رقم أو متغير ، وهذا يجعل الرقم أو المتغير سلبيًا. إذا كان الرقم أو المتغير سلبيًا بالفعل ، يصبح إيجابيًا.

C يفعل نفس الشيء: ضع `-` أمام رقم أو متغير - هذا التأثير ، مثل:

```C
int number = -3;
number = -number;
``` 

لذلك ، يبدأ `number` بالسالب 3 ، لكن يصبح بعد ذلك إيجابيًا نظرًا لأن السلبية سالبة إيجابية.

## عمليات Bitwise

لأن C مستوى منخفض كما ذكر من قبل ، يمكنك الوصول إلى وحدات البت الثنائية الفردية (إذا اخترت الاستفادة من هذا). هناك بعض العمليات الثنائية التي بنيت في دعونا نفعل ذلك. في هذه الأمثلة ، سنستخدم `a` و `b` كمتغيراتنا. يمكن أن يكون أي نوع من المتغيرات لأن كل المتغيرات سيتم تمثيلها في وحدات البت ، لذلك لا يهم نوع البيانات الدقيق لهذه.

### و

`c = a & b;` سوف تقوم بعمل bitwise AND. وهذا يعني أنه إذا كان الشيء الأول من `a` وبت الأول من `b` على حد سواء 1، بت الأول من ج سيكون 1 و 0 خلاف ذلك. إذا كانت البتة الثانية من `a` و `b` كلاهما 1 ، فإن البتة الثانية من c ستكون 1 و 0 خلاف ذلك. يستمر هذا حتى يتم كل البتات.

### أو

`c = a | b;` سوف تقوم بتنفيذ دالة OR تكون البتة الأولى من `c` 1 إذا كانت البتة الأولى في `a` أو `b` هي 1 ، تكون البتة الثانية 1 إذا كانت البتة الثانية في `a` أو `b` هي 1 ، وهكذا.

### ليس

`b = ~a;` سيتم تعيين `b` إلى تكملة `a` ، مما يعني أن أي 1 يصبح 0 و 0 يصبح أي 1.

### XOR

`c = a ^ b;` سوف تقوم بإجراء XOR. هذا حصري أو بمعنى أن البتة الأولى من `c` هي 1 إذا كانت `a` أو `b` هي 1 ، ولكن ليس كليهما. الثانية هي 1 إذا كان إما 1 ولكن ليس كلاهما ، وهلم جرا.

### تحول

سيؤدي تغيير البتات إلى أخذ البتات ونقلها إلى بعض الأماكن إلى اليسار أو اليمين. على سبيل المثال ، لنفترض أن لدينا مجموعة من وحدات البت: `101110` . يقوم C بزيادة حسابية عند تغيير البتات. لنستخدم جدولًا لجعل هذا الأمر أكثر وضوحًا:

| بت | | 1 | 2 | 3 | 4 | 5 | 6 | | ------- | --- | --- | --- | --- | --- | --- | --- | | قبل | | 1 | 0 | 1 | 1 | 1 | 0 | | خلال | 1 | 0 | 1 | 1 | 1 | 0 | | | بعد | | 0 | 1 | 1 | 1 | 0 | 0 |

هذا هو التحول الحسيني لحركة البايت الذي يذهب إلى اليسار. لاحظ أنه في اليسار إلى اليسار ، انتهى أقصى اليسار الذي بدأ في الموضع 1 خارج المساحة التي يمكن احتواؤها ، لذلك تمت إزالته. في التحول ، ظهر فتح على اليسار ، لذلك تم ملء مع 0.

الآن دعونا نلقي نظرة على bitshift حسابية واحدة بواحد:

| بت | 1 | 2 | 3 | 4 | 5 | 6 | | | ------- | --- | --- | --- | --- | --- | --- | --- | | قبل | 1 | 0 | 1 | 1 | 1 | 0 | | | خلال | | 1 | 0 | 1 | 1 | 1 | 0 | | بعد | 1 | 1 | 0 | 1 | 1 | 1 | |

لاحظ أنه هنا فتحت فتحة في الموضع 1 ، ولكن بدلاً من أن يتم تعبئتها بمقدار 0 ، تم ملؤها بواسطة البت الأكثر أهمية. في هذه الحالة ، هذا هو 1. إذا كانت البتة التي بدأت في الموضع 1 0 ، لكانت الفجوات تمتلئ بصفر.

وذلك لأن الأرقام الموجودة على جهاز الكمبيوتر الخاص بك يتم تمثيلها باستخدام Two's Complement ، لذلك لا يؤدي التبديل بهذه الطريقة إلى جعل الرقم السالب موجبًا. يستحق Two's Complement قراءة المزيد حول ما إذا كنت مهتمًا بكيفية استخدام أجهزة الكمبيوتر للثنائي لإجراء العمليات الحسابية وتمثيل الأرقام.

لإجراء تحول لليسار ، استخدم المشغل `<<` ، مثل:

```C
c = a << b;
``` 

وهذا التحول `a` لمن اليسار `b` بت، ووضع تلك النتيجة تساوي `c` .

هذا المثال سوف يتحول `a` إلى اليمين `b` بت، وتعيين تلك النتيجة تساوي `c` .

 `c = a >> b; 
` 

## مشغلي تعيين مركبة

في بعض الأحيان تريد زيادة متغير بقيمة معينة. يمكنك فعل هذا:

```C
a = a + b;
``` 

ومع ذلك ، هذا ما يفعله مشغلو التعيين المركب. بدلا من ذلك ، يمكنك كتابة هذا ، والذي يفعل نفس الشيء بالضبط:

```C
a += b;
``` 

هذا موجود لحفنة من المشغلين الآخرين ، أيضا. في ما يلي جدول مفيد لك:

الطريق القصير الطريق الطويل : --------------: |: ------------: `a += b` | `a = a + b` `a -= b` | `a = a - b` `a *= b` | `a = a * b` `a /= b` `a = a / b` `a %= b` | `a = a % b` `a &= b` `a = a & b` `a ^= b` | `a = a ^ b` `a <<= b` | `a = a << b` `a >>= b` | `a = a >> b`

هناك أيضا `|=` ، والتي ليست على الطاولة لأن `|` حرف يكسر الجدول. إنه يتصرف مثل كل هذه العمليات الأخرى ، رغم ذلك.

## صب

في بعض الأحيان ، لا ترغب في أن يكون الرقم رقمًا ، أو إذا كنت تريد أن يكون عددًا صحيحًا أو عائمًا ، أو شيء من هذا القبيل. هذا هو ما هو الصب.

كما تتذكر من مناقشة التقسيم الصحيح ، سيعطي المثال التالي قيمة عدد صحيح بدون أي قيمة عشرية ، لأن كل من الأرقام الموجودة هي أعداد صحيحة:

```C
#include <stdio.h>

int main(void) {
    int a = 12;
    int b = 5;

    printf("a divided by b is %i", a/b);
}
``` 

ومع ذلك ، باستخدام الصب ، يمكننا تحويلها إلى طوافات باستخدام الصب. هذا يسمح لهم أن يتم تقسيمهم على شكل عوامات ، وسوف ترجع المعادلة قيمة عائمة:

```C
#include <stdio.h>

int main(void) {
    int a = 12;
    int b = 5;

    printf("a divided by b is %f", (float) a / b);
}
``` 

وهي الآن نقطة عائمة 12 مقسومة على 5 ، لذلك يقوم هذا بإعادة رقم نقطة عائمة لا يتم اقتطاعها بعد المكان العشري.

لتحويل رقم إلى `int` ، استخدم `(int)` ، لتحويله إلى ملف `double` ، استخدم `(double)` ، وهكذا.

## Math.h

هذا هو كل الأشياء المدمجة ، ولكن مثل كيف يمكنك `#include` stdio و stdbool ، يمكنك تضمين مكتبة تسمى `math.h` تحتوي هذه المكتبة على جميع أنواع الوظائف المفيدة لجميع أنواع الرياضيات. من المفيد إعطاء قراءة [لصفحة ويكيبيديا عليه](https://en.wikipedia.org/wiki/C_mathematical_functions#Overview_of_functions) إذا كنت ترغب في الحصول على القائمة الكاملة للوظائف. فيما يلي مثال على كيفية استخدام `abs` ، وهي الأولى في قائمتهم:

```C
a = abs(-1);
``` 

`abs` يحسب القيمة المطلقة للقيمة التي تم تمريرها إليه. في هذه الحالة، هو تلقي ذلك -1، لذلك سوف يتحول ذلك إلى 1، و `a` سوف يكون على قدم المساواة إلى 1. وهناك الكثير أكثر لإعطاء أكثر من ذلك بكثير وظائف، وهذه هي الطريقة التي سوف تكون قادرة على القيام الدعاة، وحساب المثلثات، وأكثر بكثير.

# قبل أن تذهب ...

## مراجعة

*   هناك حفنة المزيد من مشغلي الرياضيات في C
*   ترتيب العمليات موجود في C
*   توجد الأقواس وتعمل مثل الرياضيات العادية لتغيير ترتيب العمليات
*   هناك عدد قليل من عمليات Unary ، وهي عمليات لا يوجد بها سوى متغير واحد:
*   تُستخدم عوامل ما بعد الإصلاح والإصلاحات المسبقة لإضافة وطرح 1
*   إضافة واحد: `++a;` أو `a++;`
*   طرح واحد: `--a` أو "a--"
*   `-` يمكن وضعه أمام متغير أو رقم ويعمل تمامًا مثل سلبي في الرياضيات
*   هناك بعض عمليات البت ، أيضا
*   ويتم مع &
*   أو يتم مع |
*   NOT يتم مع ~
*   XOR تتم مع ^ (لا يعمل XOR مع رقم نوع عائم في C)
*   توجد عمليات تخصيص مركبة لجميع العمليات غير أحادية
*   a + = b هو نفسه a = a + b ، وهكذا
*   يتيح لك Cast التبديل بين أنواع البيانات
*   math.h لديه المزيد من الاشياء الرياضيات للعب مع
