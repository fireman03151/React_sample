---
title: Arrays and Strings
localeTitle: المصفوفات والسلاسل
---
# المصفوفات في C

تسمح صفائف لمجموعة من المتغيرات لتجميع معا كمتغير واحد. هذا مفيد في حد ذاته ، ولكن أيضًا لأن السلاسل تقع في هذه الفئة. الأوتار ، وهي الطريقة التي نمثل بها الكلمات والجمل في لغات الكمبيوتر ، هي مجرد مجموعة من المتغيرات الشخصية. لذلك ، فإننا نمثل السلاسل باستخدام المصفوفات في C.

## جعل مجموعة

سيتم الإعلان عن متغير صحيح عادي على النحو التالي:

 `int my_variable; 
` 

لإعلان هذا كصفيف ، وجعله مصفوفة من 5 أعداد صحيحة ، يمكن الإعلان عنه على النحو التالي:

 `int my_array[5]; 
` 

سيؤدي ذلك إلى إنشاء صفيف يسمى `my_array` يمكنه الاحتفاظ بـ 5 أعداد صحيحة. ومع ذلك ، لم يتم تعيين أي من المواضع في الصفيف (حتى الآن). يمكنك تحديد الصفيف ، وتعيين القيم في البداية:

 `int my_array[] = {1, 5, 3, 6, 2}; 
` 

لاحظ أنه في هذا المثال ، لم نتعامل مع تحديد رقم في الأقواس المربعة. وذلك لأن الأقواس المتعرجة لها قيم فيها سيتم تعيينها لكل موضع في الصفيف. يمكنك وضع رقم في الأقواس على أي حال ، طالما أنك تأكد من إنشاء مواقع ذاكرة كافية لتخزين القيم التي مررت بها.

عند تهيئة صفيف ، يمكنك تقديم قيم أقل من عناصر الصفيف. على سبيل المثال ، يقوم البيان التالي بتهيئة أول عنصرين فقط من my\_array:

float my\_array \[5\] = {5.0، 2.5}؛

إذا قمت بتهيئة مصفوفة بشكل جزئي ، يقوم المحول البرمجي بتعيين العناصر المتبقية إلى صفر.

والآن بعد أن تم التصريح عن الصفيف بقيم 5 ، فإنه يحتوي على 5 مواقع للذاكرة. خذ بعين الاعتبار هذا الجدول للحصول على مثال مرئي لذلك:

| الموقف 0 | 1 | 2 | 3 | 4 | | ---------- | --- | --- | --- | --- | --- | | القيمة | 1 | 5 | 3 | 6 | 2 |

لاحظ أنه على الرغم من وجود 5 مواقع ذاكرة ، فإن مواضع الصفيف ترتفع فقط إلى 4. وهذا لأن المصفوفات في C (ومعظم اللغات الأخرى) تبدأ عند 0 ، لأنه يتم تنفيذ المصفوفات باستخدام المؤشرات. عندما تتصل بموضع في صفيف ، فأنت بالفعل تتصل بموقع الذاكرة هذا بالإضافة إلى رقم معين. للحصول على بداية الصفيف ، قم بنقل 0 مكان في الذاكرة ، للحصول على الموضع بعد ذلك ، قم بتحريك مكان واحد في الذاكرة ، وهكذا.

في ما يلي مثال على تعيين المصفوفة إلى 9 في الموضع 1:

 `my_array[1] = 9; 
` 

لذلك ، تمامًا مثل أي متغير آخر ، باستثناء أنه يحتوي على قيم متعددة للوصول باستخدام الرقم داخل الأقواس المربعة. يمكن إرجاع القيم بهذه الطريقة أيضًا:

 `int variable = my_array[4]; 
` 

هذا سوف يعلن `variable` ليكون عدد صحيح يساوي القيمة في الموضع 4 من `my_array` . ومع ذلك ، نظرًا لأن `variable` هو `int` مفرد وليس صفيفًا ، فهذا **ليس** رمزًا سيحقق النتيجة الصحيحة:

 `// This code will NOT work properly! 
 int variable = my_array; 
` 

يمكن وضع أي عدد صحيح في الأقواس المربعة للحصول على موضع في الصفيف. يمكن أن تكون تلك الأعداد الصحيحة متغيرات أيضًا. ألق نظرة على هذا المثال ، الذي يطبع محتويات مصفوفة:

 `#include <stdio.h> 
 
 int main(void) { 
    int my_array[] = {1, 1, 2, 3, 5, 7, 12}; 
 
    for(int count = 0; count < 7; count++) { 
        printf("%i, \n", my_array[count]); 
    } 
 
    return 0; 
 } 
` 

## سلاسل

الصفائف هي مجموعات من المتغيرات ، والسلاسل عبارة عن مجموعات من الأحرف. ونتيجة لذلك ، يمكننا تمثيل السلاسل باستخدام مصفوفة. _يمكنك_ يعلن شيء في نفس الطريقة كما في السابق، ولكن ستحتاج إلى وضع '\\ 0' واحدة من القيم الخاصة بك (أكثر على ذلك في دقيقة واحدة!):

 `char hello_world[] = {'H', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\0'}; 
` 

ييكيس. هذا ليس حقا حلا رائعا. لحسن الحظ ، يوفر C طريقة أفضل مع وضع السلاسل في الاعتبار:

 `char hello_world[] = "Hello world!"; 
` 

هذا أجمل بكثير. لا يتطلب منك حتى وضع "\\ 0" في النهاية ، إما. إذن ماذا كان هذا؟

### إنهاء الفصل

يتم إنهاء السلاسل في C فارغة ، مما يعني أنها تنتهي بالحرف الصفري. بهذه الطريقة ، سيعرف المحول البرمجي (ورمزك الخاص بك وكل شخص آخر) حيث تنتهي السلسلة: بمجرد أن يكون الحرف فارغًا ، تنتهي السلسلة.

بالطبع ، لا يوجد زر "فارغة" على لوحة المفاتيح ، ولكنك لا تزال بحاجة إلى كتابتها بطريقة ما. هذا ما يفعله \\ 0. عندما يرى المترجم C \\ 0 ، سيقوم بإدراج حرف فارغ. إنها تشبه طريقة \\ n طباعة سطر جديد.

### سلاسل الطباعة

شيء آخر يجعل C أسهل بالنسبة لنا هو طباعة الأوتار. بدلاً من إجبارك على طباعة كل حرف في الصفيف ، يمكنك فقط استخدام محدد تنسيق٪ s ، وتعامل السلسلة كما تفعل مع أي قيمة `int` أو `double` . في ما يلي مثال على الترحيب ، البرنامج العالمي منذ البداية ، والذي أصبح أكثر تعقيدًا مع السلاسل:

 `#include <stdio.h> 
 
 int main(void) { 
    char hello_world[] = "Hello, World!\n"; 
    printf("%s", hello_world); 
 
    return 0; 
 } 
` 

### اللعب مع سلاسل

سلاسل الطباعة سهلة ، لكن العمليات الأخرى أكثر تعقيدًا بعض الشيء. ولحسن الحظ ، `string.h` مكتبة `string.h` على بعض الوظائف المفيدة لاستخدامها في عدد من المواقف.

#### النسخ: `strcpy`

`strcpy` (من 'نسخة السلسلة') نسخ سلسلة. على سبيل المثال ، سينسخ مقتطف الشفرة محتويات السلسلة `second` في السلسلة `first` :

 `strpy(first, second); 
` 

في ما يلي مثال على الكيفية التي يبدو بها التنفيذ اليدوي لوظيفة strcpy:

void copy _string (char \[\] first_ string، char \[\] second\_string) { int i؛

 `for(i = 0; first_string[i] != '\0'; i++) 
 { 
    first_string[i] = second_string[i]; 
 } 
` 

}

#### سلسة: `strcat`

`strcat` (من "سلسلة سلسلة") سَلسَلة سلسلة ، بمعنى أنها ستأخذ محتويات سلسلة واحدة وتضعها في نهاية سلسلة أخرى. في هذا المثال ، سيتم تجميع محتويات `second` `first` :

 `strcat(first, second); 
` 

في ما يلي مثال على التنفيذ اليدوي لـ strat fuction:

void string\_concatenate (char \[\] s1، char \[\] s2) { int i = strlen (s1)، j؛ لـ (int j = 0؛ s2 \[j\]؛ j ++، i + = 1) { s1 \[i\] = s2 \[j\]؛ } }

#### الحصول على الطول: `strlen`

`strlen` (من "طول السلسلة") قيمة عدد صحيح تتطابق مع طول السلسلة. في هذا المثال ، سيتم تعيين عدد صحيح باسم `string_length` على طول `my_string` :

 `string_length = strlen(my_string); 
` 

هنا هو تنفيذ يدوي من strlen fuction:

int string\_length (char \[\] سلسلة) { int i؛

 `for(int i = 0; string[i]; i++); 
 
 return i; 
` 

}

#### قارن: `strcmp`

يقارن `strcmp` (من 'مقارنة السلسلة') سلسلتين. القيمة الصحيحة التي تقوم بإرجاعها هي 0 إذا كانت هي نفسها ، ولكنها ستعود أيضًا سالبة إذا كانت قيمة الأول (بإضافة الأحرف) أقل من قيمة الثانية ، وإيجابية إذا كان الأول أكبر من الثاني . ألق نظرة على مثال لكيفية استخدام هذا:

 `if(!strcmp(first, second)){ 
    printf("These strings are the same!\n"); 
 } else { 
    printf("These strings are not the same!\n"); 
 } 
` 

لاحظ `!` ، وهي مطلوبة لأن هذه الدالة تقوم بإرجاع 0 إذا كانت هي نفسها. إن وضع نقطة التعجب هنا سيجعل المقارنة صحيحة.

#### تقسيم سلسلة: `strtok`

`strtok` (من "رمز السلسلة") يقطع سلسلة في سلسلة من الرموز المميزة باستخدام محدد. في هذا المثال ، يقطع strtok str str في سلسلة من الرموز المميزة باستخدام delimiter delim:

 `char *strtok(char *str, const char *delim); 
` 

# قبل أن تذهب ...

## مراجعة

*   الصفائف هي مجموعات من المتغيرات.
*   تحتوي الصفائف على مواضع منفصلة يمكن الإعلان عنها باستخدام أقواس ، ويتم الوصول إليها باستخدام أقواس مربعة.
*   السلاسل عبارة عن صفائف أيضًا ، ولكن يمكننا التعامل معها بطريقة مختلفة قليلاً: يمكن الإعلان عنها باستخدام علامات اقتباس مزدوجة ، وطباعتها باستخدام٪ s.
*   سلاسل لديها مكتبة خاصة بهم ، `string.h` ، والتي لديها بعض الوظائف المفيدة للاستخدام.