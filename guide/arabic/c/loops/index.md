---
title: Loops of all kinds
localeTitle: الحلقات من جميع الأنواع
---
# الحلقات من جميع الأنواع في C

الحلقات هي ما تستخدمه عندما يكون لديك شفرة تريد تكرارها ، مما يعني أنه بعد تشغيلها ، قد تحتاج إلى تكرار الحلقة إلى البداية وتشغيلها مرة أخرى. هناك عدد قليل من هذه في C.

## في حين حلقات

أبسط من حفنة هي في حين حلقات. بينما سيتم تشغيل الحلقات بينما يكون الشرط الموجود بين الأقواس صحيحًا. يجب أن تستخدم عندما تريد أن يحدث شيء ما حتى تحدث حالة معينة.

### بناء الجملة

 `while(condition) { 
   statement(s); 
 } 
` 

إليك مثال على ذلك:

 `#include <stdio.h> 
 
 int main(void) { 
    int my_number = 0; 
 
    while(my_number != 10){ 
        ++my_number; 
    } 
 
    printf("my_number = %i", my_number); 
 
    return 0; 
 } 
` 

في حين أن العبارة داخل حلقة أثناء صحيحة ، سيتم تشغيل المحتوى داخل الأقواس. عندما يضرب البرنامج `while(my_number)` ، فإنه يتحقق من العبارة داخل الأقواس. إذا كانت هذه العبارة خاطئة ، فلن تقوم بتشغيل حلقة while. بدلاً من ذلك ، سيتم تخطي التعليمة البرمجية بين القوسين بين قوسين وسيتم التقاطها من حيث توقفت.

إذا كان البيان صحيحًا ، فسيتم تشغيل التعليمة البرمجية داخل الأقواس. بمجرد تشغيل التعليمة البرمجية داخل الأقواس ، سيتم التحقق من العبارة داخل القوس مرة أخرى. تمامًا كما كان من قبل ، إذا كانت العبارة صحيحة ، فسيتم تشغيل الشفرة ، إذا كانت خاطئة ، سيتم تخطي الرمز.

الشيء الذي قد تصادفه عند اللعب مع هذه الحلقة أو أي حلقة أخرى هو فكرة حلقة لا نهائية يمكن تشغيلها لعدد لا نهائي من المرات لأنه لا يوجد شيء لإيقافه. في بعض الأحيان يمكن أن يحدث هذا عن قصد:

 `while(1) { 
    printf("This will get printed forever unless the program is stopped!"); 
 } 
` 

بالطبع ، يمكن أن يحدث أيضا عن طريق الخطأ. إليك الشفرة نفسها التي كانت عليها من قبل ، ولكن مع اختلاف دقيق يجعلها في حلقة لا نهائية:

 `#include <stdio.h> 
 
 int main(void) { 
    int my_number = 11; 
 
    while(my_number != 10){ 
        ++my_number; 
    } 
 
    printf("my_number = %i", my_number); 
 
    return 0; 
 } 
` 

عندما يتم تقييم هذه الحلقة في `my_number` ، سيتم التحقق من `my_number` لمعرفة ما إذا كانت ليست 10. لم يتم ذلك ، لأنه تمت تهيئتها في 11 ، لذا سيتم تشغيل الشفرة داخل الحلقة بينما سيكون `my_number` 12. 12 لا يساوي 10 ، لذلك سيتم تشغيل التعليمات البرمجية داخل حلقة أثناء و `my_number` سيكون 13. سوف يستمر تشغيل هذا إلى الأبد لأن هذا الشرط لن تصبح خاطئة أبداً - الطريقة الوحيدة للتوقف هو أن يتم فرض البرنامج للتوقف عن التشغيل. هذا مثال على حلقة لا نهائية ، لأنه إذا تُرك بمفرده ، فسوف يتم تشغيل عدد لا نهائي من المرات.

## هل أثناء حلقات

تعتبر "مهام المهام" أقل استخدامًا من حلقة "وقت". بينما تبدأ الحلقات بتقييم ، لذلك إذا كان هذا التقييم خاطئًا ، فلن يتم تشغيل الشفرة داخل الأقواس. ومع وجود حلقة do-while ، يتم تشغيل الكود الموجود بين الأقواس مرة واحدة ، ثم يتم تنفيذ التقييم لمعرفة ما إذا كان يجب تشغيله مرة أخرى.

### بناء الجملة

 `do { 
   statement(s); 
 } while( condition ); 
` 

وإليك نظرة على ذلك:

 `#include <stdio.h> 
 
 int main(void){ 
    int a = 0; 
 
    do { 
        a++ 
    } while(a == -123); 
 
    printf("%i\n", a); 
 
    return 0; 
 } 
` 

إذا كانت هذه حلقة مستمرة ، فلن يتم تشغيل الرمز الموجود بين الأقواس لأن هذا الشرط ليس صحيحًا عند إجراء التقييم. ومع ذلك ، نظرًا لأن هذه حلقة do-while ، سيتم تنفيذ الكود مرة واحدة ، ثم يتم إجراء التقييم لمعرفة ما إذا كان يجب إجراء ذلك مرة أخرى. تعد "مهام المهام أثناء العمل" مفيدة عندما تعرف أنك تريد القيام بشيء ما مرة واحدة ، ولكن قد تحتاج إلى تشغيله مرة أخرى بعد ذلك.

## للحلقات

بالنسبة إلى الحلقات عندما نريد تشغيل شيء ما لعدد معين من المرات.

### بناء الجملة

 `for(initialisation; condition; changer) 
 { 
   statement(s); 
 } 
` 

إليك مثال على ذلك:

 `#include <stdio.h> 
 
 int main(void) { 
    int a = 4; 
    int b = 2; 
    int result = 0; 
 
    for(int count = 0; count != b; count++) { 
        result = result + a; 
    } 
 
    printf("a times b is %i\n", result); 
 
    return 0; 
 } 
` 

الضرب هو مجرد تكرار زائد ، لذلك هذا هو إضافة على `a` ، `b` مرة. دعونا نلقي نظرة على على `for` قمة على وجه الخصوص:

 `for(int count = 0; count != b; count++) 
` 

على عكس الحلقة ، هناك ثلاثة أشياء في قوسينا مفصولة بفواصل منقوطة. القسم الأول هو التهيئة ، ويشار إليه بـ "التهيئة": فهو يسمح لك بإنشاء متغير جديد وتعيين قيمة له ، أو تعيين متغير موجود إلى قيمة مختلفة ، أو لا يمكنك تعيين أي شيء ووضعه فاصلة منقوطة.

القسم التالي عبارة عن شرط منطقي سيتم التحقق منه صوابًا أو خطأ ، تمامًا كما هو الحال في حلقة العمل. يشار إليه على أنه "شرط" ، لأنه الشرط الذي سيتم التحقق منه قبل بدء حلقة.

يشار إلى القسم الأخير باسم "الزيادة / التناقص". وتتمثل مهمتها في إجراء بعض العمليات في كل حلقة - عادة ما تضيف أو تطرح من المتغير الأولي - بعد أن يتم تنفيذ الشفرة داخل الأقواس. في هذه الحالة ، يتم إضافة واحد فقط إلى العدد. هذه هي الطريقة الأكثر شيوعًا لاستخدام الزيادة ، لأنها تتيح لك الاحتفاظ بعدد المرات التي قمت فيها بتشغيل من خلال حلقة for.

### مقارنة بناء الجملة

 `main() 
 { 
  int i = 1; 
  while(i<=5) 
  { 
     printf(“While”); 
     i++; 
   } 
  getch(); 
 } 
 
 
 main() 
 { 
  int i = 1; 
  do 
  { 
     printf(“do-while”); 
     i++; 
   } while(i<=5); 
  getch(); 
 
 } 
 
 
 main() 
 { 
  int i 
  for(i=1;i<=5;i++) 
  { 
     printf(“for”); 
   } 
  getch(); 
 } 
` 

# بيانات التحكم في الحلقة

تغيير عبارات التحكم حلقة تنفيذ التتابع العادي الخاص به. عندما يترك التنفيذ نطاقًا ، يتم إتلاف جميع الكائنات التلقائية التي تم إنشاؤها في هذا النطاق.

يدعم C عبارات التحكم التالية:

#### 1\. بيان الاستراحة

ينهي بيان **الحلقة** أو **المفتاح** وينقل التنفيذ إلى العبارة التالية مباشرة للحلقة أو المفتاح.

#### 2\. متابعة البيان

يتسبب في الحلقة لتخطي بقية الجسم وإعادة اختبار حالته على الفور قبل التكرار.

#### 3\. غوتو البيان

التحويلات السيطرة على البيان المسمى.

# بعض المرح والمفيدة المراوغات

## حلقات لانهائية مع الحلقات

خذ لحظة للنظر في ما سيفعله هذا الرمز:

 `for(;;){ 
    printf("hello, world! \n"); 
 } 
 
 while("Free Code Camp"){ 
    printf("hello, world! \n"); 
 } 
` 

لا يوجد شيء في قسم التهيئة ، لذا لم تتم تهيئة أي شيء. هذا أمر جيد ، ويتم ذلك أحيانًا لأنك لا تريد دائمًا أو تحتاج إلى تهيئة أي شيء.

التالي هو الشرط ، وهو فارغ. هذا غريب بعض الشيء. هذا يعني أنه لن يتم اختبار أي حالة ، لذا لن يكون الأمر كاذبًا ، لذلك سيتم تشغيله من خلال الحلقة ، وتنفيذ الفكرة (التي لا تفعل شيئًا) ، ثم التحقق من الحالة مرة أخرى ، مما سيجعلها تعمل مرة أخرى. كما أدركت على الأرجح ، هذه حلقة لا نهائية. كما تبين ، هذا مفيد بالفعل. عند إنشاء حلقة لا نهائية ، تكون طريقة العمل `while(1)` شرعية تمامًا ، ولكنها تُجري مقارنة في كل مرة. `for(;;)` ، من ناحية أخرى ، لا. لهذا السبب ، `for(;;)` له استخدام شرعي في أنه شعر أكثر كفاءة من الطرق الأخرى من حلقات لانهائية. لحسن الحظ ، سوف يعتني العديد من المجمعين بهذا من أجلك.

سيتم تنفيذ الحلقة في الكود الثاني أثناء ("Free Code Camp") أيضًا بشكل لا نهائي. ويرجع السبب في ذلك إلى اعتبار C أي قيمة غير صفرية كحقيقة وبالتالي سيتم تنفيذ الحلقة بلا حدود.

## لا تستخدم الأقواس

خلال هذه الصفحة ، قرأت أن الكود "داخل الأقواس" هو ما يتم تشغيله ، وهذا صحيح في الغالب. ومع ذلك ، ماذا لو لم تكن هناك أقواس؟

 `while(true) 
    printf("hello, world! \n"); 
` 

في حالات مثل هذه ، سيعامل C السطر التالي باعتباره المحتوى الوحيد الذي يحتاج إلى حلقات. يتجاهل C المسافات البيضاء ، بحيث تكون المسافة البادئة موجودة فقط للوضوح. سيتم التعامل مع ذلك السطر فقط كما لو كان في الحلقة ، وهذه خاصية إذا كانت هناك عبارات لكل حلقات وحلقات أثناء المشاركة. نظرًا لأنه يتم تجاهل المساحة البيضاء ، فإن موضع الإعلان لا يهم: يمكن أن يكون على نفس السطر أو السطر التالي أو 300 سطر ومسافتين لأسفل طالما لا توجد أسطر أخرى من الكود بينهما. يمكن أن تجعل هذه الميزة التعليمات البرمجية تبدو منظفاً قليلاً عندما يكون لديك سطر واحد فقط من التعليمات البرمجية لتشغيل في عبارة.

## الفواصل المنقوطة بدلاً من الأقواس

إذا لم تكن هناك أقواس ، سيبدو المحول البرمجي فقط في السطر التالي ويكون ذلك هو محتوى الحلقة. تخبر الفواصل المنقوطة المترجم بأن الخط قد انتهى. مع هذه الأشياء مجتمعة ، يمكن أن ننتظر C حتى يصبح شيء صحيح. لنفترض أن لدينا طريقة تسمى `is_button_pressed` وترجع false إذا لم يتم الضغط على زر ، وصحيح إذا تم الضغط على زر:

 `while(!is_button_pressed()); 
` 

لا يحدث شيء في هذه الحلقة ، لأن الخط الوحيد الذي سينظر إليه هو فاصلة منقوطة. نتيجة لذلك ، سيتم استدعاء الأسلوب `is_button_pressed` ، وسيتم تقييم قيمة الإرجاع الخاصة به. إذا لم يتم الضغط على الزر وكانت قيمة الإرجاع خاطئة ، فإن `!` سوف تقلبه إلى true حتى يتم تشغيل الوظيفة مرة أخرى وتقييمها مرة أخرى. إذا كانت قيمة الإرجاع صحيحة ، فإن `!` سوف تقلبه إلى false وستخرج الحلقة الداخلية.

هذا له تأثير وضع إيقاف مؤقت في التعليمات البرمجية. في هذه الحالة ، وصل الرمز إلى حلقة أثناء ، ولم يذهب إلى أبعد من ذلك. بدلاً من ذلك ، استمر في التحقق من حالة الزر لتغييره. سيكون هذا مفيدًا عندما تريد ألا يحدث شيء حتى يتم استيفاء شرط معين.

# قبل أن تذهب ...

## مراجعة

*   الحلقات تسمح بتشغيل الكود أكثر من مرة ، عند استيفاء شروط معينة.
*   هناك زوجين من الحلقات المتاحة لنا في C:
*   في حين الحلقات ، والتي تسمح لنا بتشغيل التعليمات البرمجية في حين أن الشرط هو الصحيح
*   Do-while loops ، والتي تقوم بتشغيل التعليمة البرمجية ثم متابعة تشغيلها إذا كان الشرط صحيحًا
*   بالنسبة إلى الحلقات ، التي تشغل الشفرة أثناء تحقق الشرط وتسمح لنا بإجراء عملية كل حلقة.

## استخدام الحلقات لتصميم الأنماط.

#### مثال 1: برنامج لطباعة نصف الهرم باستخدام \*

 `* 
 * * 
 * * * 
 * * * * 
 * * * * * 
` 

**مصدر الرمز**

 `#include <stdio.h> 
 
 int main() 
 { 
    int i, j, rows; 
 
    printf("Enter number of rows: "); 
    scanf("%d",&rows); 
 
    for(i=1; i<=rows; ++i) 
    { 
        for(j=1; j<=i; ++j) 
        { 
            printf("* "); 
        } 
        printf("\n"); 
    } 
    return 0; 
 } 
` 

#### مثال 2: برنامج لطباعة نصف الهرم باستخدام الأرقام

 `1 
 1 2 
 1 2 3 
 1 2 3 4 
 1 2 3 4 5 
` 

**مصدر الرمز**

 `#include <stdio.h> 
 
 int main() 
 { 
    int i, j, rows; 
 
    printf("Enter number of rows: "); 
    scanf("%d",&rows); 
 
    for(i=1; i<=rows; ++i) 
    { 
        for(j=1; j<=i; ++j) 
        { 
            printf("%d ",j); 
        } 
        printf("\n"); 
    } 
    return 0; 
 } 
` 

#### مثال 3: برنامج لطباعة نصف الهرم باستخدام الحروف الهجائية

 `A 
 BB 
 CCC 
 DDDD 
 EEEEE 
` 

**مصدر الرمز**

 `#include <stdio.h> 
 
 int main() 
 { 
    int i, j; 
    char input, alphabet = 'A'; 
 
    printf("Enter the uppercase character you want to print in last row: "); 
    scanf("%c",&input); 
 
    for(i=1; i <= (input-'A'+1); ++i) 
    { 
        for(j=1;j<=i;++j) 
        { 
            printf("%c", alphabet); 
        } 
        ++alphabet; 
 
        printf("\n"); 
    } 
    return 0; 
 } 
` 

برامج لطباعة نصف الهرم المقلوب باستخدام \* والأرقام

#### مثال 4: نصف الهرم المقلوب باستخدام \*

 `* * * * * 
 * * * * 
 * * * 
 * * 
 * 
` 

**مصدر الرمز**

 `#include <stdio.h> 
 
 int main() 
 { 
    int i, j, rows; 
 
    printf("Enter number of rows: "); 
    scanf("%d",&rows); 
 
    for(i=rows; i>=1; --i) 
    { 
        for(j=1; j<=i; ++j) 
        { 
            printf("* "); 
        } 
        printf("\n"); 
    } 
 
    return 0; 
 } 
` 

#### مثال 5: هرم نصف مقلوب باستخدام الأرقام

 `1 2 3 4 5 
 1 2 3 4 
 1 2 3 
 1 2 
 1 
` 

**مصدر الرمز**

 `#include <stdio.h> 
 
 int main() 
 { 
    int i, j, rows; 
 
    printf("Enter number of rows: "); 
    scanf("%d",&rows); 
 
    for(i=rows; i>=1; --i) 
    { 
        for(j=1; j<=i; ++j) 
        { 
            printf("%d ",j); 
        } 
        printf("\n"); 
    } 
 
    return 0; 
 } 
` 

#### مثال 6: برنامج لطباعة الهرم الكامل باستخدام \*

 `        * 
      * * * 
    * * * * * 
  * * * * * * * 
 * * * * * * * * * 
` 

**مصدر الرمز**

 `#include <stdio.h> 
 
 int main() 
 { 
    int i, space, rows, k=0; 
 
    printf("Enter number of rows: "); 
    scanf("%d",&rows); 
 
    for(i=1; i<=rows; ++i, k=0) 
    { 
        for(space=1; space<=rows-i; ++space) 
        { 
            printf("  "); 
        } 
 
        while(k != 2*i-1) 
        { 
            printf("* "); 
            ++k; 
        } 
 
        printf("\n"); 
    } 
 
    return 0; 
 } 
` 

#### مثال 7: برنامج لطباعة الهرم باستخدام الأرقام

 `        1 
      2 3 2 
    3 4 5 4 3 
  4 5 6 7 6 5 4 
 5 6 7 8 9 8 7 6 5 
` 

**مصدر الرمز**

 `#include <stdio.h> 
 
 int main() 
 { 
    int i, space, rows, k=0, count = 0, count1 = 0; 
 
    printf("Enter number of rows: "); 
    scanf("%d",&rows); 
 
    for(i=1; i<=rows; ++i) 
    { 
        for(space=1; space <= rows-i; ++space) 
        { 
            printf("  "); 
            ++count; 
        } 
 
        while(k != 2*i-1) 
        { 
            if (count <= rows-1) 
            { 
                printf("%d ", i+k); 
                ++count; 
            } 
            else 
            { 
                ++count1; 
                printf("%d ", (i+k-2*count1)); 
            } 
            ++k; 
        } 
        count1 = count = k = 0; 
 
        printf("\n"); 
    } 
    return 0; 
 } 
` 

#### مثال 8: الهرم الكامل المعكوس باستخدام \*

 `* * * * * * * * * 
  * * * * * * * 
    * * * * * 
      * * * 
        * 
` 

**مصدر الرمز**

 `#include<stdio.h> 
 
 int main() 
 { 
    int rows, i, j, space; 
 
    printf("Enter number of rows: "); 
    scanf("%d",&rows); 
 
    for(i=rows; i>=1; --i) 
    { 
        for(space=0; space < rows-i; ++space) 
            printf("  "); 
 
        for(j=i; j <= 2*i-1; ++j) 
            printf("* "); 
 
        for(j=0; j < i-1; ++j) 
            printf("* "); 
 
        printf("\n"); 
    } 
 
    return 0; 
 } 
` 

#### مثال 9: طباعة مثلث باسكال

 `           1 
         1   1 
       1   2   1 
     1   3   3    1 
   1  4    6   4   1 
 1  5   10   10  5   1 
` 

**مصدر الرمز**

 `#include <stdio.h> 
 
 int main() 
 { 
    int rows, coef = 1, space, i, j; 
 
    printf("Enter number of rows: "); 
    scanf("%d",&rows); 
 
    for(i=0; i<rows; i++) 
    { 
        for(space=1; space <= rows-i; space++) 
            printf("  "); 
 
        for(j=0; j <= i; j++) 
        { 
            if (j==0 || i==0) 
                coef = 1; 
            else 
                coef = coef*(i-j+1)/j; 
 
            printf("%4d", coef); 
        } 
        printf("\n"); 
    } 
 
    return 0; 
 } 
` 

#### مثال 10: طباعة مثلث فلويد.

 `1 
 2 3 
 4 5 6 
 7 8 9 10 
` 

**مصدر الرمز**

 `#include <stdio.h> 
 
 int main() 
 { 
    int rows, i, j, number= 1; 
 
    printf("Enter number of rows: "); 
    scanf("%d",&rows); 
 
    for(i=1; i <= rows; i++) 
    { 
        for(j=1; j <= i; ++j) 
        { 
            printf("%d ", number); 
            ++number; 
        } 
 
        printf("\n"); 
    } 
 
    return 0; 
 } 
`