---
title: Arrays
localeTitle: المصفوفات
---
# المصفوفات في C

## مشاكل

قبل محاولة شرح المصفوفات ، دعنا نلقي نظرة على الكود الذي نريد طباعة 10 أرقام من قبل المستخدم بترتيب عكسي.

 `#include <stdio.h> 
 int main(void) { 
    int a, b, c, d, e, f, g, i, j, k; 
    scanf("%d", &a); 
    scanf("%d", &b); 
    ... 
    printf("%d", k); 
    printf("%d", j); 
    printf("%d", i); 
    ... //and so on.. 
 
    return 0; 
 } 
` 

لذلك ، يبدو هذا مملاً بعض الشيء. حتى الآن ، كان لكل متغير تم إنشاؤه دور خاص. ولكن في الوقت الحالي ، سيكون من الرائع أن نتمكن فقط من تخزين قيم متعددة في مكان واحد والحصول على القيم مع مكانها في الخط ربما (القيمة الأولى والثانية وما إلى ذلك). هناك طريقة أخرى للنظر إلى هذا ، لنفترض أنك تريد تخزين مجموعة من الأسماء ، لا تحتاج إلى إنشاء متغيرات مختلفة لكل اسم ، بدلاً من ذلك يمكنك إنشاء مجموعة من الأسماء حيث يكون لكل اسم هويته الفريدة أو _فهرسها_ . أيضا ، يمكن أن نستخدم الحلقات عليها ، وهي الأشياء التي ستتعلمها فيما بعد ، ولكن في الأساس يفعلون الشيء نفسه مرارا وتكرارا. على سبيل المثال. القراءة من المستخدم ، أو طباعة القيم.

## المصفوفات في C

المصفوفات هي حاويات ذات حجم معين. تحتوي على متغيرات من **نفس النوع** . يمكنك الوصول إلى متغير تم تخزينه في الصفيف مع _فهرسه_ . دعونا ننظر في بعض التعليمات البرمجية:

 `#include <stdio.h> 
 int main(void) { 
    int arr[4] = {1, 2, 3, 88}; 
    int brr[] = {78, 65}; 
    int crr[100] = {3}; 
 
    int var = arr[0]; 
 
    return 0; 
 } 
` 

والآن دعنا نكسر بناء الجملة قليلاً:

 `int arr[4] = {1, 2, 3, 88}; 
` 

هنا قمت بإنشاء `array` من `ints` (أعداد صحيحة) ، تسمى `arr` . تحتوي هذه المجموعة على 4 عناصر: `1` ، `2` ، `3` ، `88` . لاحظ بناء الجملة!

 `datatype name[number of elements] 
` 

العنصر الأول من هذه المجموعة هو `1` ، والثاني هو `2` وما إلى ذلك.

 `int brr[] = {78, 65}; 
` 

ليس عليك أن تخبر البعد مسبقًا. هنا سيتم إنشاء مجموعة من اثنين مع العناصر بين الأقواس المتعرجة.

 `int crr[100] = {3}; 
` 

إذا قمت بذلك ، فسيكون العنصر الأول هو `3` ، ولكن سيكون الباقي هو `0` .

 `int var = arr[0]; 
` 

هنا يتم إنشاء كثافة العمليات int تُسمى `var` ، ويتم تهيئتها إلى العنصر 0 من arr. **من المستورد جدا أن نلاحظ** أنه في C ، تبدأ الفهارس عند الصفر مقابل 1. وهذا يعني أنه للوصول إلى العنصر الأول ، يكون المؤشر (بين قوسين) 0 ، للوصول إلى العنصر الثاني ، المؤشر هو 1 الخ. في هذا المثال ، سيقوم `var` بتخزين القيمة `1` .

## نظرة عامة

*   يشبه المصفوفة أحادية البعد القائمة ؛ المصفوفة ثنائية الأبعاد تشبه الطاولة. لا تضع لغة C حدودًا على عدد الأبعاد في مصفوفة ، على الرغم من إمكانية تنفيذ عمليات محددة.
    
*   تشير بعض النصوص إلى صفائف أحادية البعد باعتبارها ناقلة ، صفائف ثنائية الأبعاد كمصفوفات ، وتستخدم مصفوفات المصطلح العام عندما يكون عدد الأبعاد غير محدد أو غير مهم.
    

## صفائف متعددة الأبعاد في C

كما يدعم C صفائف متعددة الأبعاد.

 `datatype name[size1][size2]...[sizeN] 
` 

صفائف ثنائية الأبعاد شائعة ويمكن تهيئتها باستخدام الصيغة التالية. يمكن للمرء أن يفكر منطقيًا في أول فهرس كصفوف والفهرس الثاني كأعمدة. يحتوي هذا المثال على صفين و 5 أعمدة.

 `int arr[2][5] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; 
` 

قد يكون من الصعب تصور صفيف ثنائي الأبعاد باستخدام البنية الموضحة أعلاه حتى يستخدم المطورون أقواسًا اختيارية متداخلة لتوضيح بنية الصفيف. هذه أيضًا طريقة صالحة لتهيئة مصفوفة ثنائية الأبعاد.

 `int arr[2][5] = { 
    {0, 1, 2, 3, 4}, 
    {5, 6, 7, 8, 9} 
 }; 
` 

يمكن استخدام اثنين متداخلين من أجل حلقات لطباعة محتويات صفيف ثنائي الأبعاد في تنسيق جدولي.

 `#include <stdio.h> 
 
 
 int main() { 
    const int rows = 2, cols = 5; 
 
    int arr[rows][cols] = { 
            {0, 1, 2, 3, 4}, 
            {5, 6, 7, 8, 9} 
    }; 
 
    for (int row = 0; row < rows; row++) { 
        for (int col = 0; col < cols; col++) { 
            printf("%5d", arr[row][col]); 
        } 
        puts(""); 
    } 
 
    return 0; 
 } 
` 

 `    0    1    2    3    4 
    5    6    7    8    9 
` 

## سلاسل

لتخزين سلاسل / أحرف متعددة ، نستخدم `char arrays` في C ، لأن اللغة ليس بها نوع خاص تم إنشاؤه. هناك شيء واحد يجب أن يكون على دراية به ، هو أن نهاية null يتم إضافتها تلقائيًا إلى النهاية ، مما يشير إلى أنها نهاية السلسلة. ومع ذلك ، قد تقوم أيضًا بتهيئة سلسلة تحتوي على أقواس معقوفة `{}` أيضًا ، ولكن يجب عليك إضافة النهاية الخالية يدويًا.

مثل ذلك:

 `char string[6] = "Hello"; //here you get Hello\0, which is why we need an array with the length of 6 
` 

كما هو الحال مع المصفوفات int في المثال أعلاه ، هناك عدة طرق لتعيين قيم لصفائف char:

 `char string[] = "I do not want to count the chars in this."; 
 char string2[] = {'C','h','a','r',' ','b','y',' ','c','h','a','r','\0'}; 
 char string3[] = "This is a string" 
                 "with two lines"; 
` 

مكافئ للنهج أعلاه ، يمكنك أيضًا إنشاء مؤشر إلى مجموعة char:

 `char* string = "I do not want to count the chars in this."; 
` 

## أخطاء نموذجية ، نصائح

*   عندما يكون لديك مصفوفة مليئة بالقيم وترغب في إنشاء صفيف آخر مماثل تمامًا لأول مرة ، لا تفعل ذلك مطلقًا:

 `double first[] = {2,3,7}; 
 double second[] = first; 
 //Or this: 
 double a[5], b[5] 
 a = b; 
` 

يمكنك **فقط** التعامل مع القيم في صفيف واحد تلو الآخر. لا **يمكنك تعيين الكل مرة واحدة** ، عندما تتعرف على المؤشرات لاحقًا ، ستكون الأسباب واضحة.

> (بشكل أساسي ، يشير العنصر الأول من صفيف إلى عنوان ذاكرة ، والعناصر بعد ذلك هي "المنازل" بجوار ذلك الأول. لذلك ، من الناحية الفنية ، فإن المصفوفة هي عنوان ذاكرة العنصر الأول فقط. عندما تريد تعيين الثانية صفيف الصفيف الأول ، كنت في خطأ بسبب أنواع مختلفة ، أو كنت تحاول تغيير عنوان الذاكرة الثاني من العنصر الأول في الصفيف الثاني.)

*   عندما تريد إنشاء مصفوفة ، يجب عليك إما معرفة حجمها ، أو تعيين قيم لها. لا تفعل هذا:

 `int arr[]; 
` 

يجب أن يعرف الكمبيوتر حجم التخزين الذي يجب إنشاؤه للصفيف. في وقت لاحق ، سوف تتعلم طرق إنشاء حاويات يتم تحديد حجمها فيما بعد. (مرة أخرى ، المؤشرات.)

*   عندما تقوم بفهرسة المصفوفة ، لن يقوم المترجم دائمًا بإعطائك خطأ. هذا ما يسمى السلوك غير معرف ، نحن لا نعرف ما الذي سيحدث. يمكن أن يؤدي إلى تعطل برنامجك ، ببساطة تباطؤ ، أي شيء.

 `int test[6]; 
 int a = test[-2]; 
 int b = test[89]; 
` 

السبب في أن C لا يتحقق من تقييد الفهرسة بسيط: C هي لغة فعالة. تم إعداده ، بحيث يكون البرنامج الأسرع: يتواصل بشكل جيد مع الأجهزة الخ. لا يحتوي كود C المكتوب بشكل جيد على أخطاء في الفهرسة ، فلماذا تريد C أن تتحقق أثناء التشغيل؟

*   عند محاولة الوصول إلى العنصر الأخير من الصفيف. لنفترض أن طول الصفيف A يكون 4 وعند الوصول إلى العنصر الأخير كـ سيعرض A \[4\] خطأ ، نظرًا لأن الفهرسة تبدأ من 0.