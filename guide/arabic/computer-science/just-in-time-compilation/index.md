---
title: Just in Time Compilation
localeTitle: فقط في وقت تجميع
---
## فقط في وقت تجميع

التجميع في الوقت المناسب هو طريقة لتحسين أداء البرامج المفسرة. أثناء التنفيذ ، قد يتم تجميع البرنامج في كود أصلي لتحسين أدائه. ومن المعروف أيضا باسم التجميع الديناميكي.

التجميع الديناميكي له بعض المزايا على التجميع الثابت. عند تشغيل تطبيقات Java أو C # ، يمكن لبيئة التشغيل أن تقوم بتوصيف التطبيق أثناء تشغيله. هذا يسمح لتوليد رمز أكثر الأمثل. في حالة تغيير سلوك التطبيق أثناء تشغيله ، يمكن لبيئة التشغيل إعادة ترجمة التعليمات البرمجية.

تتضمن بعض العيوب تأخير بدء التشغيل و overhead التجميع أثناء وقت التشغيل. للحد من الحمل ، يقوم العديد من برامج التحويل البرمجي JIT فقط بتجميع مسارات التعليمات البرمجية التي يتم استخدامها بشكل متكرر.

### نظرة عامة

تقليديا هناك طريقتان لتحويل شفرة المصدر إلى نموذج يمكن تشغيله على النظام الأساسي. يعمل التحويل الثابت على تحويل الشفرة إلى لغة لمنصة معينة. يقوم المترجم مباشرة بتنفيذ شفرة المصدر.

يحاول JIT تجميع استخدام فوائد كل منهما. أثناء تشغيل البرنامج المفسر ، يقوم المترجم JIT بتحديد الشيف الأكثر استخدامًا ويقوم بترجمته إلى رمز الجهاز. بالاعتماد على المحول البرمجي ، يمكن القيام بذلك على طريقة أو قسم أصغر من التعليمات البرمجية.

تم وصف التجميع الديناميكي لأول مرة في ورقة كتبها J. McCarthy على LISP في عام 1960.

Just In Time Compilation ، JIT ، أو Dynamic Translation ، هو تجميع يتم تنفيذه أثناء تنفيذ البرنامج. بمعنى ، وقت التشغيل ، بدلاً من قبل التنفيذ. ما يحدث هو ترجمة لرمز الآلة. ترجع مزايا JIT إلى حقيقة أنه منذ أن يتم التحويل البرمجي في وقت التشغيل ، يتمكن مترجم JIT من الوصول إلى معلومات وقت التشغيل الديناميكي مما يمكنه من إجراء تحسينات أفضل (مثل وظائف التضمين).

ما هو مهم لفهم تجميع JIT ، هو أنه سيقوم بتجميع البايت كود في تعليمات كود الآلة الخاصة بالجهاز الجاري تشغيله. بمعنى أنه تم تحسين رمز الجهاز الناتج لبنية وحدة المعالجة المركزية لجهاز التشغيل.

مثالان من JIT Compilers هما: JVM (Java Virtual Machine) في Java و CLR (Common Language Runtime) ، في C #.

## يقف JIT لـ Just-in-Time مما يعني أنه يتم تجميع التعليمات البرمجية عند الحاجة إليها ، وليس قبل وقت التشغيل.

في البداية ، كان المترجم مسؤولاً عن تحويل لغة عالية المستوى (محددة كمستوى أعلى من المجمّع) إلى رمز الكائن (تعليمات الآلة) ، والتي سيتم ربطها (بواسطة رابط) في ملف قابل للتنفيذ.

عند نقطة واحدة في تطور اللغات ، يقوم المترجمون بتجميع لغة عالية المستوى في الشفرة الزائفة ، والتي سيتم تفسيرها (بواسطة مترجم) لتشغيل البرنامج. أدى ذلك إلى التخلص من رمز الكائن والملفات القابلة للتنفيذ ، وسمح لهذه اللغات بأن تكون محمولة إلى أنظمة تشغيل متعددة وأنظمة تشغيل الأجهزة. كان باسكال (التي تم تجميعها إلى P-Code) واحدًا من الأول ؛ تعد Java و C # من الأمثلة الحديثة. في نهاية المطاف تم استبدال مصطلح P-Code بـ bytecode ، لأن معظم العمليات الزائفة هي بايت طويلة.

مترجم Just-In-Time (JIT) عبارة عن ميزة لمترجم وقت التشغيل ، بدلاً من تفسير bytecode في كل مرة يتم فيها استدعاء أسلوب ، سيقوم بتجميع البايت كود في تعليمات رمز الجهاز الخاصة بالجهاز قيد التشغيل ، ثم استدعاء هذا كود الكائن بدلا من ذلك. من الناحية المثالية فإن كفاءة تشغيل رمز الكائن ستتغلب على عدم كفاءة إعادة تجميع البرنامج في كل مرة يتم تشغيلها.

يعمل مترجم JIT بعد بدء البرنامج ويقوم بترجمة الشفرة (عادةً bytecode أو نوع من تعليمات VM) على الطاير (أو فقط في الوقت المناسب ، كما يطلق عليه) في نموذج يكون عادة أسرع ، وعادة ما يكون المضيف الأصلي للمضيف CPU مجموعة التعليمات. يمكن لـ JIT الوصول إلى معلومات وقت التشغيل الديناميكية بينما لا يقوم المترجم القياسي بإجراء تحسينات أفضل مثل تضمين وظائف يتم استخدامها بشكل متكرر.

هذا على النقيض من المترجم التقليدي الذي يجمع كل الكود إلى لغة الآلة قبل تشغيل البرنامج لأول مرة.

لإعادة صياغة ، compilers التقليدية إنشاء البرنامج بالكامل كملف EXE BEFORE في المرة الأولى التي تقوم بتشغيلها. بالنسبة للبرامج ذات النمط الأحدث ، يتم إنشاء تجميع باستخدام pseudocode (p-code). فقط بعد تنفيذ البرنامج على نظام التشغيل (على سبيل المثال ، عن طريق النقر المزدوج على أيقونة) ، سيقوم المترجم (JIT) بتشغيل رمز الآلة (m-code) وتوليده ، بحيث يفهم المعالج القائم على Intel أو أي شيء.

## السيناريو النموذجي:

يتم تحويل رمز المصدر بالكامل إلى رمز الجهاز

## سيناريو JIT:

سيتم تحويل الكود المصدري إلى لغة التجميع مثل البنية \[للامتثال IL (لغة وسيطة) لـ C # ، ByteCode لـ java\].

يتم تحويل الشفرة الوسيطة إلى لغة الآلة فقط عندما يحتاج التطبيق إلى رموز مطلوبة فقط يتم تحويلها إلى كود الآلة.

## مقارنة JIT مقابل غير JIT:

في JIT ، لا يتم تحويل كل الكود إلى كود الآلة أولاً ، سيتم تحويل جزء من الكود الضروري إلى كود الآلة ، ثم إذا لم تكن هناك طريقة أو وظيفة تسمى في الجهاز ، فسيتم تحويلها إلى كود الآلة ... فهي تقلل من العبء على وحدة المعالجة المركزية. كما سيتم إنشاء رمز الجهاز في وقت التشغيل ... سوف ينتج مترجم JIT رمز الجهاز الذي تم تحسينه من أجل تشغيل CPU وحدة المعالجة. أمثلة JIT:

في Java JIT في JVM (Java Virtual Machine) في C # يكون في CLR (وقت تشغيل اللغة العامة) في Android ، يوجد في DVM (الجهاز الظاهري Dalvik) أو ART (Android RunTime) في إصدارات أحدث.

يحتفظ Java Virtual Machine (JVM) (JVM executes bytecode) باحتساب عدد الوقت الذي يتم فيه تنفيذ الدالة. إذا تجاوز هذا العدد حدًا محددًا مسبقًا ، يقوم JIT بترجمة الشفرة إلى لغة الآلة التي يمكن تنفيذها مباشرة بواسطة المعالج (على عكس الحالة العادية التي يقوم فيها javac بتجميع الرمز إلى bytecode ثم java - يفسر المترجم هذا السطر bytecode عن طريق سطر يحولها إلى رمز الجهاز وينفذ).

أيضا في المرة القادمة يتم حساب هذه الوظيفة نفس الشفرة المجمعة يتم تنفيذها مرة أخرى على عكس التفسير العادي الذي يتم فيه تفسير الشفرة مرة تلو الأخرى. وهذا يجعل التنفيذ أسرع.

#### معلومات اكثر

*   [تجميع JIT (ويكيبيديا)](https://en.wikipedia.org/wiki/Just-in-time_compilation)
*   [JIT مقدمة](https://eli.thegreenplace.net/2013/11/05/how-to-jit-an-introduction/)