---
title: Python Comparisons
localeTitle: مقارنات بايثون
---
[بيثون مستندات - المقارنات](https://docs.python.org/3/library/stdtypes.html#comparisons)

هناك ثماني عمليات مقارنة في بايثون. لديهم جميعا نفس الأولوية (وهو أعلى من العمليات المنطقية). يمكن مقارناته بشكل تعسفي. على سبيل المثال ، `x < y <= z` مكافئ `x < y and y <= z` ، فيما عدا أنه يتم تقييم `y` مرة واحدة فقط (ولكن في الحالتين `z` لا يتم تقييمه على الإطلاق عند `x < y` تم العثور على false).

يلخص هذا الجدول عمليات المقارنة:

العملية | المعنى  
\--------- | -----------------------  
`<` | بدقة أقل من  
`<=` | اقل او يساوي `>` | بدقة أكبر من `>=` | أكبر من أو يساوي `==` | يساوي `!=` | لا تساوي `is` | هوية الكائن  
`is not` هوية الكائن المنسوخة

كائنات من أنواع مختلفة ، باستثناء أنواع رقمية مختلفة ، أبدا مقارنة على قدم المساواة. علاوة على ذلك ، فإن بعض الأنواع (على سبيل المثال ، كائنات الدالة) تدعم فقط مفهومًا متدليًا للمقارنة حيث يكون أي جسمين من هذا النوع غير متساويين. ستقوم عوامل `<` ، `<=` ، `>` و `>=` برفع استثناء `TypeError` عند مقارنة رقم مركب بنوع رقمي مدمج آخر ، عندما تكون الكائنات من أنواع مختلفة لا يمكن مقارنتها ، أو في حالات أخرى حيث لا يوجد تعريف ترتيب.

عادةً ما تقارن المثيلات غير المتطابقة لفئة ما بأنها غير متساوية ما لم يعرّف الفصل الأسلوب `__eq__()` .

لا يمكن ترتيب مثيلات الفئة فيما يتعلق `__lt__()` الأخرى من نفس الفئة ، أو أنواع أخرى من الكائنات ، ما لم يحدد الفصل ما يكفي من الأساليب `__lt__()` و `__le__()` و `__gt__()` و `__ge__()` (بشكل عام و `__lt__()` و `__eq__()` كافية ، إذا كنت تريد المعنى التقليدي لمشغلي المقارنة).

سلوك `is` و `is not` المشغلين لا يمكن تخصيص. كما يمكن تطبيقها على أي جسمين ولا تثير استثناء.

يمكننا أيضا سلسلة `<` و `>` المشغلين معا. على سبيل المثال ، `3 < 4 < 5` سيعود `True` ، لكن `3 < 4 > 5` لن. يمكننا أيضا سلسلة مشغل المساواة. على سبيل المثال ، `3 == 3 < 5` سيعود `True` ولكن `3 == 5 < 5` لن.

### مقارنات المساواة - "is" vs "=="

في بايثون ، هناك نوعان من عوامل المقارنة التي تسمح لنا بالتحقق من وجود كائنين متساويين. المشغل `is` و `==` المشغل. ومع ذلك ، هناك فرق رئيسي بينهما!

يمكن تلخيص الفرق الرئيسي بين "is" و "==" على النحو التالي:

*   `is` يستخدم لمقارنة **الهوية**
*   `==` يستخدم لمقارنة **المساواة**

## مثال

أولا ، إنشاء قائمة في بيثون.

```python
myListA = [1,2,3]
``` 

بعد ذلك ، قم بإنشاء نسخة من تلك القائمة.

```python
myListB = myListA
``` 

إذا استخدمنا عامل التشغيل "==" أو عامل التشغيل "is" ، فسيؤدي كلاهما إلى إخراج **صحيح** .

```python
>>> myListA == myListB # both lists contains similar elements
True
>>> myListB is myListA # myListB contains the same elements
True
``` 

هذا لأن myListA و myListB يشيران إلى نفس متغير القائمة ، الذي عرّفته في بداية برنامج Python الخاص بي. كلا القائمتين متطابقتان تمامًا ، سواء في الهوية أو في المحتوى.

ومع ذلك ، ماذا لو أنشأت الآن قائمة جديدة؟

```python
myListC = [1,2,3]
``` 

لا يزال أداء عامل `==` يشير إلى أن كلا القائمتين متماثلتين ، من حيث المحتوى.

```python
>>> myListA == myListC
True
``` 

ومع ذلك، أداء `is` مشغل والآن تنتج `False` الانتاج. هذا لأن myListA و myListC هما متغيرين مختلفين ، بالرغم من احتوائهما على نفس البيانات. على الرغم من أنها تبدو متشابهة ، إلا أنها **مختلفة** .

```python
>>> myListA is myListC
False # both lists have different reference
``` 

لنلخص:

*   `is` ناتج التعبير `True` إذا كان كلا المتغيرين يشيران إلى نفس المرجع
*   ناتج تعبير `==` `True` إذا `True` كلا المتغيرين على نفس البيانات