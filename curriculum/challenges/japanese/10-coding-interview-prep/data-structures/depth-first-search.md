---
id: 587d825d367417b2b2512c96
title: 深さ優先探索
challengeType: 1
forumTopicId: 301640
dashedName: depth-first-search
---

# --description--

ここでは、<dfn>幅優先探索</dfn>と似ているが別のグラフ走査アルゴリズムである、<dfn>深さ優先探索</dfn>について学びます。

幅優先探索はソースノードからのエッジの長さを徐々に増やして検索しますが、<dfn>深さ優先探索</dfn>は、最初にエッジの経路のうちの 1 本をできるだけ遠くまで下ります。

経路の末端に到達すると、検索は訪問されていないエッジ経路を持つ最後のノードに引き返し、検索を続けます。

下のアニメーションはこのアルゴリズムの仕組みを示しています。 このアルゴリズムは一番上のノードから始まり、番号順にノードを訪問します。

<img class='img-responsive' src='https://camo.githubusercontent.com/aaad9e39961daf34d967c616edeb50abf3bf1235/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f372f37662f44657074682d46697273742d5365617263682e676966' />

幅優先探索とは異なり、1 つのノードを訪問するたびにすべての隣接ノードを訪れるわけではありません。 代わりに、最初に隣接ノードのいずれかを訪れ、その経路上に未訪問のノードがなくなるまで経路を下り続けます。

このアルゴリズムを実装するには、スタックを使用すると良いでしょう。 スタックは、最後に追加された要素が最初に削除されるような配列です。 これは、<dfn>後入れ先出し</dfn>のデータ構造とも呼ばれます。 スタックは、深さ優先探索アルゴリズムに役立ちます。なぜなら、スタックに隣接ノードを追加するとき、直近に追加された隣接ノードを最初に訪問してそれをスタックから取り除きたいからです。

このアルゴリズムの単純な出力は、与えられたノードから到達可能なノードのリストです。 したがって、訪問したノードの追跡も必要でしょう。

# --instructions--

無向の隣接行列 `graph` とノードラベル `root` をパラメータとして取る関数、`dfs()` を記述してください。 ノードラベルは単に `0` から `n - 1` の間の数値です (`n` はグラフ内のノードの総数)。

この関数は、`root` から到達可能なすべてのノードの配列を出力する必要があります。

# --hints--

`1` を開始ノードとする入力グラフ `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]` は、`0`、`1`、`2`、`3` を持つ配列を返す必要があります。

```js
assert.sameMembers(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 1, 0],
      [0, 1, 0, 1],
      [0, 0, 1, 0]
    ];
    return dfs(graph, 1);
  })(),
  [0, 1, 2, 3]
);
```

`3` を開始ノードとする入力グラフ `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]` は、`3`、`2`、`1`、`0` を持つ配列を返す必要があります。

```js
assert.sameMembers(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 1, 0],
      [0, 1, 0, 1],
      [0, 0, 1, 0]
    ];
    return dfs(graph, 3);
  })(),
  [3, 2, 1, 0]
);
```

`1` を開始ノードとする入力グラフ `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]` は、4 つの要素を持つ配列を返す必要があります。

```js
assert(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 1, 0],
      [0, 1, 0, 1],
      [0, 0, 1, 0]
    ];
    return dfs(graph, 1);
  })().length === 4
);
```

`3` を開始ノードとする入力グラフ `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]` は、`3` を持つ配列を返す必要があります。

```js
assert.sameMembers(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 1, 0],
      [0, 1, 0, 0],
      [0, 0, 0, 0]
    ];
    return dfs(graph, 3);
  })(),
  [3]
);
```

`3` を開始ノードとする入力グラフ `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]` は、1 つの要素を持つ配列を返す必要があります。

```js
assert(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 1, 0],
      [0, 1, 0, 0],
      [0, 0, 0, 0]
    ];
    return dfs(graph, 3);
  })().length === 1
);
```

`3` を開始ノードとする入力グラフ `[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]`は、`2` と `3` を持つ配列を返す必要があります。

```js
assert.sameMembers(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 0, 0],
      [0, 0, 0, 1],
      [0, 0, 1, 0]
    ];
    return dfs(graph, 3);
  })(),
  [2, 3]
);
```

`3` を開始ノードとする入力グラフ `[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]` は、2 つの要素を持つ配列を返す必要があります。

```js
assert(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 0, 0],
      [0, 0, 0, 1],
      [0, 0, 1, 0]
    ];
    return dfs(graph, 3);
  })().length === 2
);
```

`0` を開始ノードとする入力グラフ `[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]` は、`0` と `1` を持つ配列を返す必要があります。

```js
assert.sameMembers(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 0, 0],
      [0, 0, 0, 1],
      [0, 0, 1, 0]
    ];
    return dfs(graph, 0);
  })(),
  [0, 1]
);
```

`0` を開始ノードとする入力グラフ `[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]` は、2 つの要素を持つ配列を返す必要があります。

```js
assert(
  (function () {
    var graph = [
      [0, 1, 0, 0],
      [1, 0, 0, 0],
      [0, 0, 0, 1],
      [0, 0, 1, 0]
    ];
    return dfs(graph, 0);
  })().length === 2
);
```

# --seed--

## --seed-contents--

```js
function dfs(graph, root) {

}

var exDFSGraph = [
  [0, 1, 0, 0],
  [1, 0, 1, 0],
  [0, 1, 0, 1],
  [0, 0, 1, 0]
];
console.log(dfs(exDFSGraph, 3));
```

# --solutions--

```js
function dfs(graph, root) {
    var stack = [];
    var tempV;
    var visited = [];
    var tempVNeighbors = [];
    stack.push(root);
    while (stack.length > 0) {
        tempV = stack.pop();
        if (visited.indexOf(tempV) == -1) {
            visited.push(tempV);
            tempVNeighbors = graph[tempV];
            for (var i = 0; i < tempVNeighbors.length; i++) {
                if (tempVNeighbors[i] == 1) {
                    stack.push(i);
                }
            }
        }
    }
    return visited;
}
```
