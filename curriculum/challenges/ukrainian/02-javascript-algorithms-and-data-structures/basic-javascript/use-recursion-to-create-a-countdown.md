---
id: 5cd9a70215d3c4e65518328f
title: Використання рекурсії для створення зворотного відліку
challengeType: 1
forumTopicId: 305925
dashedName: use-recursion-to-create-a-countdown
---

# --description--

У <a href="/ukrainian/learn/javascript-algorithms-and-data-structures/basic-javascript/replace-loops-using-recursion" target="_blank" rel="noopener noreferrer nofollow">попередньому завданні</a> ви дізнались, як використовувати рекурсію для заміни циклів `for`. Тепер розглянемо складнішу функцію, яка повертає масив послідовних цілих чисел, починаючи з `1` та закінчуючи переданим числом.

Як було згадано в попередньому завданні, ми матимемо <dfn>базовий випадок</dfn>. Він повідомляє рекурсивній функції, коли їй більше не потрібно викликати саму себе. Це простий випадок, коли повернене значення вже відоме. Також існує <dfn>рекурсивний виклик</dfn>, який виконує початкову функцію з різними аргументами. Якщо функція написана правильно, то буде досягнутий базовий випадок.

Скажімо, ви хочете написати рекурсивну функцію, що повертає масив, який містить числа від `1` до `n`. Цій функції потрібно прийняти аргумент `n`, який позначає кінцеве число. Тоді їй потрібно викликати саму себе, поступово зменшуючи значення числа `n`, поки воно не досягне `1`. Ви можете написати функцію наступним чином:

```javascript
function countup(n) {
  if (n < 1) {
    return [];
  } else {
    const countArray = countup(n - 1);
    countArray.push(n);
    return countArray;
  }
}
console.log(countup(5));
```

Консоль показуватиме значення `[1, 2, 3, 4, 5]`.

Спочатку це може здатися парадоксальним, адже значення `n` *зменшується*, а значення у кінцевому масиві *збільшується*. Так відбувається через те, що збільшення відбувається останнім, після повернення рекурсивного виклику. На моменті, коли `n` поміщається у масив, `countup(n - 1)` вже проаналізовано та повернуто `[1, 2, ..., n - 1]`.

# --instructions--

Ми вже визначили функцію під назвою `countdown` з одним параметром (`n`). Функція повинна використовувати рекурсію, щоб повернути масив, який містить цілі числа від `n` до `1` на основі параметра `n`. Якщо функція викликається числом, меншим за 1, вона повинна повернути порожній масив. Наприклад, якщо викликати цю функцію із `n = 5`, повинен повернутися масив `[5, 4, 3, 2, 1]`. Ваша функція повинна використовувати рекурсію, викликаючи саму себе, та не повинна використовувати цикли.

# --hints--

`countdown(-1)` має повертати порожній масив.

```js
assert.isEmpty(countdown(-1));
```

`countdown(10)` має повертати `[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]`

```js
assert.deepStrictEqual(countdown(10), [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]);
```

`countdown(5)` має повертати `[5, 4, 3, 2, 1]`

```js
assert.deepStrictEqual(countdown(5), [5, 4, 3, 2, 1]);
```

Ваш код не повинен опиратися на жодні цикли (`for`, `while` або функції вищого порядку, як-от `forEach`, `map`, `filter` або `reduce`).

```js
assert(
  !code.match(/for|while|forEach|map|filter|reduce/g)
);
```

Ви повинні використати рекурсію, щоб розв’язати це завдання.

```js
assert(
  countdown.toString().match(/countdown\s*\(.+\)/)
);
```

Не використовуйте глобальні змінні для кешування масиву.

```js
countdown(1)
assert.deepStrictEqual(countdown(5), [5, 4, 3, 2, 1]);
```

# --seed--

## --seed-contents--

```js
// Only change code below this line
function countdown(n){
  return;
}
// Only change code above this line
```

# --solutions--

```js
function countdown(n){
   return n < 1 ? [] : [n].concat(countdown(n - 1));
}
```
