---
id: 587d7dbb367417b2b2512baa
title: Повторне використання шаблонів за допомогою груп захоплення
challengeType: 1
forumTopicId: 301364
dashedName: reuse-patterns-using-capture-groups
---

# --description--

Припустимо, ви хочете знайти збіг для слова, яке зустрічається декілька разів, як у прикладі нижче.

```js
let repeatStr = "row row row your boat";
```

Можна використати `/row row row/`, але що робити, якщо ви не знаєте, яке слово повторюється? Для пошуку повторюваних підрядків можна використовувати <dfn>групи захоплення</dfn>.

Щоб створити групу захоплення, оточіть шаблон регулярного виразу дужками. У цьому випадку метою є захопити слово, яке складається з алфавітно-цифрових символів, тому групою захоплення буде `\w+`, оточена дужками: `/(\w+)/`.

Підрядок, який збігається з групою, зберігається у тимчасовій «змінній», доступ до якої можна отримати у межах того самого регулярного виразу за допомогою зворотнього слешу і номера групи захоплення (наприклад, `\1`). Групи захоплення автоматично нумеруються за порядком відкриваючої дужки (зліва направо), починаючи з 1.

Приклад нижче збігається зі словом, яке зустрічається три рази підряд та розділене пробілом:

```js
let repeatRegex = /(\w+) \1 \1/;
repeatRegex.test(repeatStr); // Returns true
repeatStr.match(repeatRegex); // Returns ["row row row", "row"]
```

Використовуючи метод `.match()` в рядку, можна повернути масив з відповідним підрядком, а також із захопленими групами.


# --instructions--

Використайте групи захоплення в `reRegex`, щоб збігтись з рядком, який складається з однакового числа, що повторюється тричі та розділене пробілами.

# --hints--

Ваш регулярний вираз має використати скорочений символьний клас для цифр.

```js
assert(reRegex.source.match(/\\d/));
```

Ваш регулярний вираз має повторно використати групу захоплення двічі.

```js
assert(reRegex.source.match(/\\1|\\2/g).length >= 2);
```

Ваш регулярний вираз повинен збігатися з рядком `42 42 42`.

```js
reRegex.lastIndex = 0;
assert(reRegex.test('42 42 42'));
```

Ваш регулярний вираз повинен збігатися з рядком `100 100 100`.

```js
reRegex.lastIndex = 0;
assert(reRegex.test('100 100 100'));
```

Ваш регулярний вираз не повинен збігатися з рядком `42 42 42 42`.

```js
assert.equal('42 42 42 42'.match(reRegex.source), null);
```

Ваш регулярний вираз не повинен збігатися з рядком `42 42`.

```js
assert.equal('42 42'.match(reRegex.source), null);
```

Ваш регулярний вираз не повинен збігатися з рядком `101 102 103`.

```js
reRegex.lastIndex = 0;
assert(!reRegex.test('101 102 103'));
```

Ваш регулярний вираз не повинен збігатися з рядком `1 2 3`.

```js
reRegex.lastIndex = 0;
assert(!reRegex.test('1 2 3'));
```

Ваш регулярний вираз повинен збігатися з рядком `10 10 10`.

```js
reRegex.lastIndex = 0;
assert(reRegex.test('10 10 10'));
```

Ваш регулярний вираз не повинен збігатися з рядком `42\t42\t42`.

```js
reRegex.lastIndex = 0;
assert(!reRegex.test('42\t42\t42'));
```

Ваш регулярний вираз не повинен збігатися з рядком `42  42  42`.

```js
reRegex.lastIndex = 0;
assert(!reRegex.test('42  42  42'));
```

# --seed--

## --seed-contents--

```js
let repeatNum = "42 42 42";
let reRegex = /change/; // Change this line
let result = reRegex.test(repeatNum);
```

# --solutions--

```js
let repeatNum = "42 42 42";
let reRegex = /^(\d+) \1 \1$/;
let result = reRegex.test(repeatNum);
```
