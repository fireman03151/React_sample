---
id: 587d7db6367417b2b2512b9b
title: Пошук символів за допомогою лінивого збігу
challengeType: 1
forumTopicId: 301341
dashedName: find-characters-with-lazy-matching
---

# --description--

<dfn>Жадібний</dfn> збіг знаходить найдовшу частину рядка, яка відповідає шаблону регулярного виразу та повертає його як збіг. Альтернативою є <dfn>лінивий</dfn> збіг, що знаходить найменшу частину рядка, яка відповідає шаблону регулярного виразу.

Ви можете застосувати регулярний вираз `/t[a-z]*i/` до рядка `"titanic"`. Цей регулярний вираз фактично є шаблоном, який починається з `t`, закінчується на `i` та має кілька літер між ними.

Регулярні вирази за замовчуванням «жадібні», тому збіг поверне `["titani"]`. Він знаходить найбільший можливий підрядок, який відповідає шаблону.

Однак ви можете використати символ `?`, щоб змінити його на «лінивий» пошук. `"titanic"`, зіставлений зі скоригованим регулярним виразом `/t[a-z]*?i/` поверне `["ti"]`.

**Примітка:** варто уникати синтаксичного аналізу HTML (парсингу) регулярних виразів, але за допомогою регулярних виразів можна зіставляти рядок HTML з шаблоном.

# --instructions--

Виправте регулярний вираз `/<.*>/`, щоб він повернув HTML тег `<h1>`, а не текст `"<h1>Winter is coming</h1>"`. Пам’ятайте, що байдужий символ `.` в регулярному виразі відповідає будь-якому символу.

# --hints--

Змінна `result` повинна бути масивом, який містить `<h1>`

```js
assert(result[0] == '<h1>');
```

`myRegex` має використати «лінивий» пошук

```js
assert(/[^\\][\*\+\?]\?/.test(myRegex));
```

`myRegex` не повинен містити рядок `h1`

```js
assert(!myRegex.source.match('h1'));
```

# --seed--

## --seed-contents--

```js
let text = "<h1>Winter is coming</h1>";
let myRegex = /<.*>/; // Change this line
let result = text.match(myRegex);
```

# --solutions--

```js
let text = "<h1>Winter is coming</h1>";
let myRegex = /<.*?>/; // Change this line
let result = text.match(myRegex);
```
