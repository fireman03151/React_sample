---
id: 587d7db6367417b2b2512b9b
title: Як знайти символи за допомогою "лінивого" збігу
challengeType: 1
forumTopicId: 301341
dashedName: find-characters-with-lazy-matching
---

# --description--

У регулярних виразах "жадібний" збіг (<dfn>greedy</dfn>) знаходить найдовшу можливу частину рядка, яка відповідає шаблону регулярного виразу та видає його як збіг. Альтернативою є "лінивий" збіг (<dfn>lazy</dfn>), який знаходить найменшу можливу частину рядка, що відповідає шаблону регулярного виразу.

Ви можете застосувати регулярний вираз `/t[a-z]*i/` до рядка `"titanic"`. Цей регулярний вираз фактично є шаблоном, який починається з `t`, закінчується на `i` та має кілька літер між ними.

Регулярні вирази за замовчуванням "жадібні", тому збіг видасть `["titani"]`. Він знаходить найбільший можливий підрядок, який відповідає шаблону.

Однак ви можете застосувати символ `?`, щоб змінити його на "лінивий" пошук збігів. Код `"titanic"`, зіставлений зі скоригованим регулярним виразом `/t[a-z]*?i/`, видає `["ti"]`.

**Примітка:** Слід уникати синтаксичного аналізу HTML регулярних виразів, але ви можете зіставляти рядок HTML з шаблоном за допомогою регулярних виразів.

# --instructions--

Виправте регулярний вираз `/<.*>/`, аби він видав теґ HTML `<h1>`, а не текст `"<h1>Winter is coming</h1>"`. Пам'ятайте, що спеціальний символ `.` в регулярному виразі відповідає будь-якому символу.

# --hints--

Змінна `result` повинна бути масивом, який містить `<h1>`

```js
assert(result[0] == '<h1>');
```

`myRegex` повинен використовувати "лінивий" пошук збігів

```js
assert(/[^\\][\*\+\?]\?/.test(myRegex));
```

`myRegex` не повинен містити рядок `h1`

```js
assert(!myRegex.source.match('h1'));
```

# --seed--

## --seed-contents--

```js
let text = "<h1>Winter is coming</h1>";
let myRegex = /<.*>/; // Change this line
let result = text.match(myRegex);
```

# --solutions--

```js
let text = "<h1>Winter is coming</h1>";
let myRegex = /<.*?>/; // Change this line
let result = text.match(myRegex);
```
