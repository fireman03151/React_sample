---
id: 587d8256367417b2b2512c78
title: Матриця суміжності
challengeType: 1
forumTopicId: 301621
dashedName: adjacency-matrix
---

# --description--

Ще один спосіб представлення графа - у вигляді <dfn>матриці суміжності</dfn>. <dfn>Матриця суміжності</dfn> - це двовимірний (2D) масив, де кожен внутрішній масив має таку ж кількість елементів, як і зовнішній. Іншими словами, це матриця або таблиця чисел, де числа являють собою ребра.

**Зверніть увагу**: цифри зверху і зліва від матриці - це лише мітки для вузлів. Одиниці всередині матриці означають, що між вершинами (вузлами), які представляють рядок та стовпець, існує ребро. Нулі означають, що ребра чи зв'язку немає.

<pre>
    1 2 3
  \------
1 | 0 1 1
2 | 1 0 0
3 | 1 0 0
</pre>

Приклад вище - це дуже простий, неорієнтований граф з трьох вузлів, де перший вузол з'єднаний з другим та третім вузлами. Нижче подана реалізація цього прикладу за допомогою JavaScript.

```js
var adjMat = [
  [0, 1, 1],
  [1, 0, 0],
  [1, 0, 0]
];
```

На відміну від списку суміжності, кількість елементів у кожному "рядку" матриці повинна збігатися з кількістю вузлів у графі. Ось ми маємо матрицю 3 на 3, а це означає, що в нашому графі є три вузли. Подібно виглядає й орієнтований граф. Нижче наведено граф, в якому перший вузол має ребро, спрямоване до другого вузла, а другий вузол має ребро, з'єднане з третім вузлом.

```js
var adjMatDirected = [
  [0, 1, 0],
  [0, 0, 1],
  [0, 0, 0]
];
```

Графи також можуть мати <dfn>ваги</dfn> своїх ребер. Поки що ми маємо <dfn>незважені</dfn> ребра, де присутність і відсутність ребра є бінарним елементом (`0` або `1`). Ваги можуть бути різними в залежності від сфери застосування.

# --instructions--

Створіть матрицю суміжності для неорієнтованого графа з 5-ма вузлами. Ця матриця повинна бути у багатовимірному масиві. Ці п'ять вузлів мають такі зв'язки: між першим і четвертим вузлами, першим і третім вузлами, третім і п'ятим вузлами, четвертим і п'ятим вузлами. Всі ваги ребер - 1.

# --hints--

`undirectedAdjList` повинен містити лише п'ять вузлів.

```js
assert(
  adjMatUndirected.length === 5 &&
    adjMatUndirected
      .map(function (x) {
        return x.length === 5;
      })
      .reduce(function (a, b) {
        return a && b;
      })
);
```

Між першим і четвертим вузлами повинне бути ребро.

```js
assert(adjMatUndirected[0][3] === 1 && adjMatUndirected[3][0] === 1);
```

Між першим і третім вузлами повинне бути ребро.

```js
assert(adjMatUndirected[0][2] === 1 && adjMatUndirected[2][0] === 1);
```

Між третім і п'ятим вузлами повинне бути ребро.

```js
assert(adjMatUndirected[2][4] === 1 && adjMatUndirected[4][2] === 1);
```

Між четвертим і п'ятим вузлами повинне бути ребро.

```js
assert(adjMatUndirected[3][4] === 1 && adjMatUndirected[4][3] === 1);
```

# --seed--

## --seed-contents--

```js
var adjMatUndirected = [];
```

# --solutions--

```js
var adjMatUndirected = [
  [0, 0, 1, 1, 0],
  [0, 0, 0, 0, 0],
  [1, 0, 0, 0, 1],
  [1, 0, 0, 0, 1],
  [0, 0, 1, 1, 0]
];
```
