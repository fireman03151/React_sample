---
title: AVL Trees
localeTitle: AVL树
---
## AVL树

AVL树是二叉搜索树的子类型。

BST是由节点组成的数据结构。它有以下保证：

1.  每棵树都有一个根节点（在顶部）。
2.  根节点具有零个或多个子节点。
3.  每个子节点都有零个或多个子节点，依此类推。
4.  每个节点最多有两个孩子。
5.  对于每个节点，其左后代小于当前节点，该节点小于正确的后代。

AVL树有额外的保证：

6.  右子树和左子树深度之间的差异不能超过一。为了保持这种保证，AVL的实现将包括在添加附加元素时重新平衡树的算法将扰乱该保证。

AVL树的最坏情况查找，插入和删除时间为O（log n）。

### 右转

![AVL树右旋转](https://raw.githubusercontent.com/HebleV/valet_parking/master/images/avl_right_rotation.jpg)

### 左转

![AVL树左旋转](https://raw.githubusercontent.com/HebleV/valet_parking/master/images/avl_left_rotation.jpg)

### AVL插入过程

您将执行类似于普通二进制搜索树插入的插入。插入后，使用向左或向右旋转修复AVL属性。

*   如果右子树的左子节点存在不平衡，则执行左右旋转。
*   如果左子树的左子节点存在不平衡，则执行右旋转。
*   如果右子树的右子项存在不平衡，则执行左旋转。
*   如果左子树的右子项存在不平衡，则执行左右旋转。

#### 更多信息：

[YouTube - AVL树](https://www.youtube.com/watch?v=7m94k2Qhg68)

AVL树是自平衡二叉搜索树。 AVL树是二叉搜索树，具有以下属性： - >每个节点的子树的高度最多为1。 - >每个子树都是一个AVL树。

AVL树检查左侧和右侧子树的高度，并确保差异不大于1.这种差异称为平衡因子。 AVL树的高度始终为O（Logn），其中n是树中的节点数。

AVL树轮换： -

在AVL树中，在执行插入和删除等每个操作后，我们需要检查树中每个节点的平衡因子。如果每个节点都满足平衡因子条件，那么我们就结束操作，否则我们必须使其平衡。当树由于任何操作而变得不平衡时，我们使用旋转操作来使树平衡。

旋转操作用于使树平衡。有四种旋转，它们分为两种类型： - >单左旋转（LL旋转） 在LL旋转中，每个节点从当前位置向左移动一个位置。 - >单右旋转（RR旋转） 在RR Rotation中，每个节点从当前位置向右移动一个位置。 - >左右旋转（LR旋转） LR旋转是单个左旋转然后单个右旋转的组合。在LR Rotation中，首先每个节点从当前位置向左移动一个位置，然后向右移动一个位置。 - >左右旋转（RL旋转） RL旋转是单右旋转然后单左旋转的组合。在RL旋转中，首先每个节点从当前位置向右移动一个位置然后向左移动一个位置。