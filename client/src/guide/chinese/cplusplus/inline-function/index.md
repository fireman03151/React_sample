---
title: Inline Function
localeTitle: 内联函数
---
# 内联函数

## 介绍

内联函数是一个在C ++中定义的特殊函数，在调用时会内联扩展。

现在，这究竟意味着什么？

每当调用一个函数时，它需要花费很多额外的时间来执行一系列活动，例如跳转到函数，保存寄存器，将参数推入堆栈并返回到调用函数。所以需要很多时间。但内联函数是一种函数，其中已请求编译器执行内联扩展。函数请求编译器在调用函数的每个位置插入函数的完整主体，而不是生成代码以在定义它的一个位置调用函数。

但是，我们无法保证内联声明的每个函数都是内联的。因为当我们将函数声明为`inline` ，它是一个请求，而不是一个命令。在以下情况下，编译器可能会忽略内联请求： - 1）如果函数包含循环，例如`for`循环， `while`循环， `do-while`循环等。 2）如果函数包含`switch`或`goto`语句。 3）如果提到返回类型（当然不是`void`的话），该功能不返回任何内容。 4）如果函数包含静态变量。 5）如果函数包含递归调用。

\`\`\`c ++

## 句法 ：-

内联返回_类型函数_名称（argument\_list）{

//函数体

}
```
## When to use Inline function 
 
 * When the function performs small tasks and is called very often. 
 * When performance is important. 
 * Instead of a macro. 
```

C ++

# 包括

使用命名空间std;

class MathOperation {

上市：
```
inline int add(int x, int y){ 
 
  return(x+y); 
 } 
 
 inline float div(int n1, float n2){ 
 
  return(n1/n2); 
 } 
```

};

int main（）{

MathOperation obj;

cout <<“Addition is：”<< obj.add（34,12）<< <\\ n \\ n“; cout <<“分区是：”<< obj.div（12,3.4）<<“\\ n”;

返回0;

} \`\`\`

## 内联功能的优点

*   它节省了函数返回调用的开销。
*   它通过利用指令缓存增加了引用的局部性。
*   它通过避免函数调用开销来加速您的程序。
*   当函数调用发生时，它可以节省堆栈上变量推/弹操作的开销。
*   可以将函数定义放在头文件中，即它可以包含在多个编译单元中，而不会让链接器抱怨。

## 内联函数的缺点

*   在标题中使用时，它会使您的头文件更大，其中包含用户不关心的信息。
*   由于代码扩展，它增加了可执行文件的大小。
*   C ++内联在编译时解析。这意味着如果更改内联函数的代码， 您需要使用它重新编译所有代码以确保它将被更新。
*   如上所述，它增加了可执行文件的大小，这可能会导致内存中的颠簸。 更多页面错误，降低程序性能。