---
title: Python from X Import Y
localeTitle: بايثون من X استيراد Y
---
إذا كنت قد قرأت wiki `import statements` فقد رأيتني استخدم هذا البيان في أحد الأمثلة. اليوم ، سنحاول فهم ما تفعله

حتى التقاط نفس المثال:

 `>>> from math import ceil, sqrt 
 >>> # here it would be 
 >>> sqrt(36) 
 <<< 6 
` 

![:rocket:](//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2 ":صاروخ:") [تشغيل الكود](https://repl.it/CS5t/1)

أو يمكننا استخدام هذا:

 `>>> import math 
 >>> # here it would be 
 >>> math.sqrt(36) 
 <<< 6 
` 

![:rocket:](//forum.freecodecamp.com/images/emoji/emoji_one/rocket.png?v=2 ":صاروخ:") [تشغيل الكود](https://repl.it/CS5u)

ثم سيبدو لدينا رمز مثل `math.sqrt(x)` بدلاً من `sqrt(x)` . يحدث هذا لأنه عندما نستخدم `import x` ، يتم إنشاء مساحة اسم `x` نفسها لتجنب تعارضات الأسماء. يجب عليك الوصول إلى كل كائن مفرد من الوحدة النمطية كـ `x.<name>` . ولكن عندما نستخدم `from x import y` نوافق على إضافة `y` إلى مساحة الاسم الرئيسية الرئيسية. لذا أثناء استخدام هذا يجب علينا التأكد من عدم وجود كائن يحمل نفس الاسم في برنامجنا.

> **لا تستخدم أبدًا `from x import y` إذا كان هناك كائن مسمي `y` موجود بالفعل**

على سبيل المثال ، في وحدة `os` هناك طريقة `open` . ولكن لدينا حتى وظيفة مدمجة تسمى `open` . لذا ، هنا يجب أن نتجنب `from os import open` .

يمكننا حتى استخدام `form x import *` ، وهذا من شأنه أن يستورد جميع الأساليب ، فئات هذه الوحدة إلى مساحة الاسم العالمية للبرنامج. هذا هو ممارسة برمجة سيئة. يرجى تجنب ذلك.

بشكل عام ، يجب تجنب استخدام `from x import y` ببساطة بسبب المشكلات التي قد يسببها في البرامج واسعة النطاق. على سبيل المثال ، لا تعرف أبدًا ما إذا كان مبرمج زميل قد يرغب في إنشاء وظيفة جديدة تصادف أنها اسم إحدى الوظائف الموجودة. كما أنك لا تعرف ما إذا كانت Python ستغير المكتبة التي تقوم باستيراد الدالات منها. في حين أن هذه المشاكل لن تكون موجودة في كثير من الأحيان للمشاريع المنفردة ، كما هو مذكور من قبل ، فهي ممارسة سيئة للبرامج ويجب تجنبها.