---
title: Functional
localeTitle: وظيفي
---
 `var fun = function(a, b) { 
  var funInstance = {}; 
  funInstance.a = a; 
  funInstance.b = b; 
  funInstance.method1 = function() { 
    // method code here 
  } 
  funInstance.method2 = function() { 
    // method code here 
  } 
  funInstance.method3 = function() { 
    // method code here 
  } 
  return funInstance; 
 } 
 var myFun = fun(1, 2); 
 myFun.method1(); 
` 

## كيف يمكنني التعرف عليه؟

إنشاء مثيل كائن وظيفي بإنشاء مثيل فئة مع دالة ، مثل القيام الخيارات الأخرى. الفرق هو أنه يتم تعريف جميع الطرق المرتبطة أيضا في وظيفة المنشئ.

## لماذا أستخدمها؟

نظرًا لأنه يتم إنشاء مجموعة جديدة من الطرق لكل مثيل من الكائن ويمكن أن تستهلك مقدارًا معينًا من الذاكرة ، فإن إنشاء المظهر الوظيفي يكون جيدًا عندما تعرف أنك لن تعمل مع الكثير من الحالات. كما أنه من الجيد أيضًا أن يتم فهم الشفرة الخاصة بك بسهولة بواسطة مبرمجات جافا سكريبت الجديدة والمتمرّسة على حدٍّ سواء ، نظرًا لأن عملية التأشير تكون مستقلة تمامًا ومن السهل رؤية العلاقات بين الأساليب ومثيلات الكائن.

## ما هي عيوبه؟

الجانب السلبي مع Instantal الوظيفية هو أنه إذا قمت بإجراء أي تغييرات على التعليمات البرمجية (مثل إضافة المزيد من الطرق) ، لن يتم تحديث أي مثيلات للكائن الذي تم إنشاؤه قبل إجراء هذه التغييرات. قد ينتهي بك الأمر مع حالتين تحتويان على معلومات طرق مختلفة.

* * *

## العنوان: وظيفية المشتركة

 `var fun = function(a, b) { 
  var funInstance = {}; 
  funInstance.a = a; 
  funInstance.b = b; 
  extend(funInstance, funMethods); 
  return funInstance; 
 } 
 var extend = function(to, from) { 
  for (var key in from) { 
    to[key] = from[key]; 
  } 
 } 
 var funMethods = {}; 
 funMethods.method1 = function() { 
    // method code here 
 } 
 funMethods.method2 = function() { 
    // method code here 
 } 
 funMethods.method3 = function() { 
    // method code here 
 } 
 var myFun = fun(1, 2); 
 myFun.method1(); 
` 

## كيف يمكنني التعرف عليه؟

والفرق الرئيسي بين الوظائف والوظائف المشتركة ، هو أنه في الوظائف المشتركة نشارك أساليبنا. بدلاً من الإعلان عن طرق في وظيفة Instantiation ، لدينا كائن منفصل يحمل جميع أساليبنا. من أجل استخدام الأساليب ، نقوم بتوسيعها إلى كل مثيل من الكائن الذي يتم إنشاؤه.

## لماذا أستخدمها؟

تتيح الوظيفة المشتركة لنا استخدام المراجع إلى الأساليب ، بدلاً من التصريح عن طرقنا وتخزينها لكل مثيل من وجوهنا ، مما يوفر لنا المساحة.

## ما هي عيوبه؟

الجانب السلبي هو أنه بما أن الأساليب يتم الرجوع إليها من خلال مؤشرات إلى كائن الطرق ، إذا كنا سنقوم بتحديث كائن الطرق بأي طريقة ، فلن يتم تحديث مثيلات الكائن التي تم إنشاؤها قبل التغييرات. قد ينتهي بك الأمر مع حالتين من الكائن الذي يشير إلى إصدارين مختلفين من الأساليب.

* * *

## العنوان: Prototypal

 `var fun = function(a, b) { 
  var funInstance = Object.create(funMethods); 
  funInstance.a = a; 
  funInstance.b = b; 
  return funInstance; 
 } 
 var funMethods = {}; 
 funMethods.method1 = function() { 
    // method code here 
 } 
 funMethods.method2 = function() { 
    // method code here 
 } 
 funMethods.method3 = function() { 
    // method code here 
 } 
 var myFun = fun(1, 2); 
 myFun.method1(); 
` 

## كيف يمكنني التعرف عليه؟

يشبه Prototypal الوظيفية المشتركة في أن كلاهما يستخدمان كائن طرق منفصل لاستيعاب كافة الطرق التي سيتم مشاركتها بين مثيلات الكائن الذي نقوم بإنشائه. الفرق هو أنه يمكننا استخدام سلسلة النموذج الأولي. يمكننا إنشاء الكائن باستخدام Object.create (prototype) من أجل إرفاق الطرق إلى مثيل الكائن لدينا. يعتبر الكائن الذي يحتفظ بطرقنا المشتركة هو النموذج الأولي.

## لماذا أستخدمها؟

إذا قمت بإجراء تغييرات على النموذج الأولي الخاص بك بعد إنشاء مثيل كائن ، فسيتم تحديث ذلك المثيل. لن ينتهي الأمر مع اثنين من الحالات مع نفس النموذج الأولي التي لديها طرق مختلفة.

## ما هي عيوبه؟

تتمثل عيوب استخدام هذه الطريقة في أنها تتطلب خطوات إضافية ورمزًا إضافيًا. يجب علينا ليس فقط أن نعيد ونعيد جسمنا كما كان من قبل ، ولكن علينا أيضًا أن نزينه.

* * *

## العنوان: Pseudoclassical

 `var Fun = function(a, b) { 
  // this = Object.create(Fun.prototype); 
  this.a = a; 
  this.b = b; 
  // return this; 
 } 
 Fun.prototype.method1 = function() { 
    // method code here 
 } 
 Fun.prototype.method2 = function() { 
    // method code here 
 } 
 Fun.prototype.method3 = function() { 
    // method code here 
 } 
 var myFun = new Fun(1, 2); 
 myFun.method1(); 
` 

## كيف يمكنني التعرف عليه؟

Instantization Classical Pseudoclassical Instantiation هي إلى حد بعيد تحتوي على أقل كمية من التعليمات البرمجية. بدلاً من إنشاء كائن جديد وإعادته ، تقوم الكلمة الأساسية الجديدة بذلك. تحت غطاء محرك الأقراص ، عند استخدام الكلمة الأساسية الجديدة لإنشاء كائن ، يمكنك إنشاء كائن جديد باستخدام هذا = Object.create (Object.prototype) ، حيث يشير هذا إلى النموذج الأولي المسمى بعد الكلمة الأساسية الجديدة. عندما نعرِّف أساليبنا ، نستخدم الكلمة الرئيسية النموذجية.

## لماذا أستخدمها؟

يقال أن الكاذبة الكلاسيكية هي أسرع نموذج للاحتكاك ، وهو أمر مفيد إذا كنت تخلق عشرات الآلاف من الحالات. وهو أيضًا الأكثر ملاءمةً لأنه يستخدم وظائف جافا سكريبت.

## ما هي عيوبه؟

الجانب السلبي من Instantization الكلاسيكية الكاذبة هو أنه يتطلب معرفة أكثر قليلاً حول ما تقوم به JavaScript تحت غطاء محرك السيارة ، ولا سيما مع هذه الكلمة الأساسية. هذا يجعل هذا النوع من عملية إنشاء الكائن أكثر تعقيدًا لفهمه ، خاصة إذا كان شخص آخر يقرأ شفرتك