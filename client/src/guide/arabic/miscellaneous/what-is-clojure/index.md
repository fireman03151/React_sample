---
title: What Is Clojure
localeTitle: ما هو كلوور
---
## Clojure هي لهجة من Lisp.

Lisps هي عائلة منفصلة تمامًا من اللغات إلى لغات C-like مثل C # أو Javascript أو Python أو Ruby. هذا يعني أن ليزبس قد تبدو غريبة بالنسبة للمبرمجين الذين هم أكثر دراية بهذه اللغات. أساسا ، كونه لسب يعني أن كل شيء في Clojure هو عبارة عن قائمة تحتوي على بيانات (حتى مكالمات الدالة!) ، فإنه يحتوي على كتابة ديناميكية ، ويمكنك تحديد _وحدات الماكرو_ التي تسمح لك بمعالجة التعليمة البرمجية الخاصة بك. إليك مثال بسيط عن بعض Clojure التي يمكنك دراستها:

 `   (defn hello-world [] (println "Hello world!")) 
` 

هذا يحدد وظيفة (باستخدام الماكرو `defn` ) تسمى `hello-world` لا يأخذ أي إدخال ( `[]` ) ويطبع `"Hello world!"` إلى وحدة التحكم. يمكننا أن نسميها كما يلي:

 `   (hello-world) 
   ; => Hello world! 
   ;    nil 
` 

## Clojure هي لغة وظيفية.

جميع المتغيرات في Clojure غير قابلة للتغيير ، ولا يمكن تغييرها باستخدام عامل تعيين ( `=` في معظم لغات C-like) أو بواسطة وظيفة. تهدف جميع الوظائف إلى أن تكون _شفافة بشكل مرجعي_ ، مما يعني أنه إذا أعطيتهم نفس المدخلات ، فعليهم إعطاء نفس الناتج مهما كان. المثال `hello-world` المرحب أعلاه هو شفاف بشكل مرجعي - سيطبع دائمًا "مرحباً بالعالم!" لا يهم ماذا. شيء ما يعتمد على مولد رقم عشوائي غير شفاف بشكل مرجعي ، لأن ناتجها عشوائي.

 `  (defn random-function [] 
    (if (> (rand 4) 2)     ; if a random number between 0 and 2 is greater than 2... 
      (println "foo")      ; ...print "foo". otherwise... 
      (println "bar")))    ; ...print "bar" 
` 

على الرغم من أن عدم القدرة على تغيير المتغيرات قد يبدو مروعًا ، إلا أنه أسهل بكثير مما تعتقد ، خاصة إذا كانت اللغة مبنية حوله (مثل Clojure is!) ، ويمكن أن يؤدي تجنب التحور غير الضروري إلى جعل الكود أقل كثيرًا.

## Clojure يعمل على Java Virtual Machine.

JVM هو الجهاز الظاهري الذي يفسر جافا bytecode ويستخدمه لتشغيل البرنامج. هذا يعني أن Clojure يعمل بسلاسة تامة مع الكود المصمم لجافا (على الرغم من أنه يبدو غريبا بعض الشيء) ، وهذا يعني أيضا أنه يعمل بسرعة كبيرة مقارنة مع اللسب الأخرى. في حين أنه أبطأ قليلاً من Java ، فإنه لا يزال أسرع بكثير من Python أو Ruby أو Javascript.

 `  (.indexOf [1 2 3 4] 2) ;; .indexOf is a Java method! 
  ; => 1 
` 

## تم تصميم Clojure للتوافق.

يعني "التزامن" هنا "برنامجًا واحدًا يعمل على عدة سلاسل محادثات في وقت واحد" ، مما قد يجعل التعليمة البرمجية أسرع. ويمكن أيضا أن يجعل كود buggier الخاص بك ؛ تخيل لو كان هناك وظيفتين مختلفتين يتغيران ويقرأان من نفس الكائن في نفس الوقت! سيكون من الفوضى المطلقة. لحسن الحظ ، في Clojure ، المتغيرات هي غير قابلة للتغيير ، مما يعني أنه لا توجد فرصة لهذا النوع من الفوضى كسر فضفاضة. تحتوي اللغة أيضًا على مجموعة متنوعة من الميزات لتسهيل كتابة التعليمات البرمجية المتزامنة ، مثل نظام ذاكرة معاملات البرامج ، والوكلاء والذرات.

| ![:point_left:](//forum.freecodecamp.com/images/emoji/emoji_one/point_left.png?v=2 ": point_left:") السابق [![:book:](//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2 ":كتاب:") الصفحة الرئيسية ![:book:](//forum.freecodecamp.com/images/emoji/emoji_one/book.png?v=2 ":كتاب:")](//forum.freecodecamp.com/t/clojure-resources/18422) | [التالى ![:point_right:](//forum.freecodecamp.com/images/emoji/emoji_one/point_right.png?v=2 ": point_right:")](//forum.freecodecamp.com/t/clojure-the-basics/18410) |  
| | [جدول المحتويات](//forum.freecodecamp.com/t/clojure-resources/18422) | [أساسيات](//forum.freecodecamp.com/t/clojure-the-basics/18410) |