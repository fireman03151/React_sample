---
title: Flood Fill Algorithm
localeTitle: خوارزمية تعبئة الفيضان
---
## خوارزمية تعبئة الفيضان

تعبئة الفيضان هي خوارزمية تستخدم بشكل أساسي لتحديد منطقة محددة مرتبطة بعقدة معينة في مصفوفة متعددة الأبعاد. أنه تشابه دقيق لأداة الجرافة في برامج الطلاء.

إن تنفيذ الخوارزمية الأكثر تقارباً هو وظيفة متكررة أساسها مكدس ، وهذا ما سنتحدث عنه التالى.

### كيف يعمل؟

المشكلة بسيطة جدًا وتتبع عادةً الخطوات التالية:

1.  خذ موقف نقطة البداية.
2.  قرّر منطقيًا تريد الذهاب في 4 اتجاهات ( **N، S، W، E** ) أو 8 اتجاهات ( **N، S، W، E، NW، NE، SW، SE** ).
3.  اختر لونًا بديلًا ولونًا مستهدفًا.
4.  السفر في تلك الاتجاهات.
5.  إذا كان البلاط الذي تهبط عليه هدفًا ، فأعد إدخاله باللون المختار.
6.  كرر 4 و 5 حتى تكون في كل مكان داخل الحدود.

لنأخذ الصفيف التالي كمثال:

![نص بديل](https://github.com/firealex2/Codingame/blob/master/small%208%20grid%20paintefffd.png)

المربع الأحمر هو نقطة البداية والمربعات الرمادية هي ما يسمى الجدران.

للحصول على مزيد من التفاصيل ، في ما يلي جزء من الشفرة يصف الوظيفة:

 `int wall = -1; 
 
 void flood_fill(int pos_x, int pos_y, int target_color, int color) 
 { 
 
   if(a[pos_x][pos_y] == wall || a[pos_x][pos_y] == color) // if there is no wall or if i haven't been there 
      return;                                              // already go back 
 
   if(a[pos_x][pos_y] != target_color) // if it's not color go back 
      return; 
 
   a[pos_x][pos_y] = color; // mark the point so that I know if I passed through it. 
 
   flood_fill(pos_x + 1, pos_y, color);  // then i can either go south 
   flood_fill(pos_x - 1, pos_y, color);  // or north 
   flood_fill(pos_x, pos_y + 1, color);  // or east 
   flood_fill(pos_x, pos_y - 1, color);  // or west 
 
   return; 
 
 } 
` 

كما رأينا أعلاه ، نقطة البداية (4،4). بعد استدعاء الدالة لإحداثيات البدء **x = 4** و **y = 4** ، يمكنني البدء في التحقق إذا لم يكن هناك جدار أو لون على الفور. إذا كان ذلك صحيحًا ، أضع علامة على المكان بـ **"لون"** واحد والبدء في التحقق من المربعات adiacent الأخرى.

الذهاب إلى الجنوب سنصل إلى النقطة (5،4) و تعمل الوظيفة مرة أخرى.

### مشكلة كسسيرسيسي

اعتبرت دائمًا أن حل مشكلة (أو أكثر) / ثانية باستخدام خوارزمية مستفادة حديثًا هو أفضل طريقة لفهمها بشكل كامل المفهوم.

إذن هنا واحد:

**بيان:**

في صفيف بدائي تحصل على عدد n من **"الجزر"** . حاول أن تجد أكبر مساحة في جزيرة و رقم الجزيرة المقابل. 0 علامات الماء وأي سائر آخر بين 1 و n يساوي مربع واحد من السطح المقابل لجزيرة س.

**إدخال**

*   **ن** - عدد الجزر.
*   **ل ، ج** - أبعاد المصفوفة.
*   خطوط **ل** المقبلة، أرقام **ج** إعطاء **ل** صف من المصفوفة عشر.

**انتاج |**

*   **أنا** - عدد الجزيرة مع أكبر مساحة.
*   **أ** - منطقة **ط** 'الجزيرة عشر.

**مثلا:**

لديك المدخلات التالية:

 `2 4 4 
 0 0 0 1 
 0 0 1 1 
 0 0 0 2 
 2 2 2 2 
` 

والتي سوف تحصل على الجزيرة لا. 2 كأكبر جزيرة بمساحة 5 مربعات.

### إشارة

المشكلة سهلة للغاية ، ولكن في ما يلي بعض التلميحات:

 `1. Use the flood-fill algorithm whenever you encounter a new island. 
 2. As opposed to the sample code, you should go through the area of the island and not on the ocean (0 tiles). 
`