---
title: B Trees
localeTitle: Árboles b
---
## Árboles b

# Introducción

B-Tree es un árbol de búsqueda de auto-equilibrio. En la mayoría de los otros árboles de búsqueda de equilibrio automático (como AVL y Red Black Trees), se supone que todo está en la memoria principal. Para comprender el uso de B-Trees, debemos pensar en una gran cantidad de datos que no caben en la memoria principal. Cuando el número de claves es alto, los datos se leen del disco en forma de bloques. El tiempo de acceso al disco es muy alto en comparación con el tiempo de acceso a la memoria principal. La idea principal de utilizar B-Trees es reducir la cantidad de accesos al disco. La mayoría de las operaciones del árbol (búsqueda, inserción, eliminación, máx, mín., Etc.) requieren O (h) accesos de disco donde h es la altura del árbol. El árbol B es un árbol gordo. La altura de los B-Trees se mantiene baja al colocar las claves máximas posibles en un nodo B-Tree. En general, un tamaño de nodo B-Tree se mantiene igual al tamaño de bloque de disco. Como h es bajo para B-Tree, los accesos totales al disco para la mayoría de las operaciones se reducen significativamente en comparación con los Árboles de búsqueda binarios balanceados como AVL Tree, Red Black Tree, ... etc.

Propiedades del árbol B: 1) Todas las hojas están al mismo nivel. 2) Un árbol B se define por el término grado mínimo 't'. El valor de t depende del tamaño del bloque de disco. 3) Cada nodo, excepto la raíz, debe contener al menos t-1 claves. La raíz puede contener un mínimo de 1 llave. 4) Todos los nodos (incluida la raíz) pueden contener como máximo 2t - 1 claves. 5) El número de hijos de un nodo es igual al número de claves en él más 1. 6) Todas las claves de un nodo están ordenadas en orden creciente. El elemento secundario entre dos teclas k1 y k2 contiene todas las teclas en el rango de k1 y k2. 7) B-Tree crece y se contrae desde la raíz, lo cual es diferente al Binary Search Tree. Búsqueda binaria Los árboles crecen hacia abajo y también se encogen hacia abajo. 8) Al igual que otros árboles de búsqueda binaria equilibrados, la complejidad del tiempo para buscar, insertar y eliminar es O (Logn).

Buscar: La búsqueda es similar a la búsqueda en el árbol binario de búsqueda. Que la clave a buscar sea k. Partimos de la raíz y recursivamente descendemos. Para cada nodo no hoja visitado, si el nodo tiene una clave, simplemente devolvemos el nodo. De lo contrario, recurriremos al elemento secundario apropiado (el elemento secundario justo antes de la primera clave mayor) del nodo. Si alcanzamos un nodo hoja y no encontramos k en el nodo hoja, devolvemos NULL.

Atravesar: Traversal también es similar a Inorder traversal of Binary Tree. Comenzamos desde el niño más a la izquierda, imprimimos recursivamente al niño más a la izquierda, luego repetimos el mismo proceso para los niños restantes y las teclas. Al final, imprime recursivamente al niño más a la derecha.